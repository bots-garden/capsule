{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Capsule: the nano (wasm) functions runner \ud83d\udea7 This is a wip Issues: https://github.com/bots-garden/capsule/issues Last release: v0.2.8 \ud83e\udda4 [dodo] Dev release: v0.2.9 \ud83e\udd9c [parrot] \ud83d\udea7 in progress What is Capsule ? Capsule is a WebAssembly function launcher(runner). It means that, with Capsule you can: From your terminal, execute a function of a wasm module (the \"CLI mode\" ) Serving a function of a wasm module through http (the \"HTTP mode\" ) Serving a function of a wasm module through NATS (the \"NATS mode\" ), in this case Capsule is used as a NATS subscriber and can reply on a subject(topic) Serving a function of a wasm module through MQTT (the \"MQTT mode\" ), in this case Capsule is used as a MQTT subscriber and can reply on a subject(topic) Capsule is developed with GoLang and thanks to the \ud83d\udc9c Wazero project The wasm modules are developed in GoLang and compiled with TinyGo (with the WASI specification) What's new v0.2.8 : Capsule uses now Fiber instead Gin . The size of the Capsule Runner Docker image is now 16.8M! v0.2.7 : The FaaS components are externalized, now, this project is only for the Capsule Runner \"Scratch\" Docker image (18.5M) to easily use and deploy the Capsule Runner (https://github.com/bots-garden/capsule-docker-image) cabu (or capsule-builder ) (https://github.com/bots-garden/capsule-function-builder): a CLI using a specific Docker image allowing: the creation of a wasm function project (from templates) the build of the wasm function, without installing anything (TinyGo is embedded in the image) (https://github.com/bots-garden/capsule-function-builder) v0.2.6 : Wazero: updates to 1.0.0-pre.2 by @codefromthecrypt + a logo v0.2.5 : Add MQTT support by @py4mac with MqttPublish & MqttPublish v0.2.4 : Add 2 wasm helper functions flatjson.StrToMap and flatjson.MapToStr (update 2022/10/10: these two helpers has been removed) v0.2.3 : NATS support, 2 new functions: NatsReply and NatsConnectRequest v0.2.2 : like 0.2.1 with fixed modules dependencies, and tag name start with a v 0.2.1 : NATS support (1st stage) OnNatsMessage , NatsPublish , NatsConnectPublish , NatsConnectPublish , NatsGetSubject , NatsGetServer 0.2.0 : OnLoad & OnExit functions + Memory cache host functions ( MemorySet , MemoryGet , MemoryKeys ) 0.1.9 : Add Request and Response types (for the Handle function) 0.1.8 : Redis host functions: add the KEYS command ( RedisKeys(pattern string) )","title":"Home"},{"location":"#capsule-the-nano-wasm-functions-runner","text":"\ud83d\udea7 This is a wip Issues: https://github.com/bots-garden/capsule/issues Last release: v0.2.8 \ud83e\udda4 [dodo] Dev release: v0.2.9 \ud83e\udd9c [parrot] \ud83d\udea7 in progress","title":"Capsule: the nano (wasm) functions runner"},{"location":"#what-is-capsule","text":"Capsule is a WebAssembly function launcher(runner). It means that, with Capsule you can: From your terminal, execute a function of a wasm module (the \"CLI mode\" ) Serving a function of a wasm module through http (the \"HTTP mode\" ) Serving a function of a wasm module through NATS (the \"NATS mode\" ), in this case Capsule is used as a NATS subscriber and can reply on a subject(topic) Serving a function of a wasm module through MQTT (the \"MQTT mode\" ), in this case Capsule is used as a MQTT subscriber and can reply on a subject(topic) Capsule is developed with GoLang and thanks to the \ud83d\udc9c Wazero project The wasm modules are developed in GoLang and compiled with TinyGo (with the WASI specification)","title":"What is Capsule?"},{"location":"#whats-new","text":"v0.2.8 : Capsule uses now Fiber instead Gin . The size of the Capsule Runner Docker image is now 16.8M! v0.2.7 : The FaaS components are externalized, now, this project is only for the Capsule Runner \"Scratch\" Docker image (18.5M) to easily use and deploy the Capsule Runner (https://github.com/bots-garden/capsule-docker-image) cabu (or capsule-builder ) (https://github.com/bots-garden/capsule-function-builder): a CLI using a specific Docker image allowing: the creation of a wasm function project (from templates) the build of the wasm function, without installing anything (TinyGo is embedded in the image) (https://github.com/bots-garden/capsule-function-builder) v0.2.6 : Wazero: updates to 1.0.0-pre.2 by @codefromthecrypt + a logo v0.2.5 : Add MQTT support by @py4mac with MqttPublish & MqttPublish v0.2.4 : Add 2 wasm helper functions flatjson.StrToMap and flatjson.MapToStr (update 2022/10/10: these two helpers has been removed) v0.2.3 : NATS support, 2 new functions: NatsReply and NatsConnectRequest v0.2.2 : like 0.2.1 with fixed modules dependencies, and tag name start with a v 0.2.1 : NATS support (1st stage) OnNatsMessage , NatsPublish , NatsConnectPublish , NatsConnectPublish , NatsGetSubject , NatsGetServer 0.2.0 : OnLoad & OnExit functions + Memory cache host functions ( MemorySet , MemoryGet , MemoryKeys ) 0.1.9 : Add Request and Response types (for the Handle function) 0.1.8 : Redis host functions: add the KEYS command ( RedisKeys(pattern string) )","title":"What's new"},{"location":"capsule-faas/","text":"Capsule FaaS (experimental) There are four additional components to use Capsule (the wasm module launcher/executor) in FaaS mode: capsule-registry : a wasm module registry (\ud83d\udea7 support of https://wapm.io/ in progress) capsule-reverse-proxy : a reverse-proxy to simplify the functions (wasm modules) access capsule-worker : a server to start the functions (wasm modules) remotely capsule-ctl (short name: caps ): a CLI to facilitate the interaction with the worker You can use the capsule registry independently of FaaS mode, only to provide wasm modules to the capsule launcher You can use the capsule reverse-proxy independently of FaaS mode, only to get only one access URL","title":"Capsule FaaS"},{"location":"capsule-faas/#capsule-faas-experimental","text":"There are four additional components to use Capsule (the wasm module launcher/executor) in FaaS mode: capsule-registry : a wasm module registry (\ud83d\udea7 support of https://wapm.io/ in progress) capsule-reverse-proxy : a reverse-proxy to simplify the functions (wasm modules) access capsule-worker : a server to start the functions (wasm modules) remotely capsule-ctl (short name: caps ): a CLI to facilitate the interaction with the worker You can use the capsule registry independently of FaaS mode, only to provide wasm modules to the capsule launcher You can use the capsule reverse-proxy independently of FaaS mode, only to get only one access URL","title":"Capsule FaaS (experimental)"},{"location":"dev-guide/","text":"Developer Guide First CLI function Create a go.mod file: ( go mod init cli-say-hello ) module cli-say-hello go 1.18 Install the Capsule dependencies: go get github.com/bots-garden/capsule/capsulemodule/hostfunctions Create a hello.go file: package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main() { hf.SetHandle(Handle) } func Handle(params []string) (string, error) { var err error for _, param := range params { hf.Log(\"- parameter is: \" + param) } ret := \"The first parameter is: \" + params[0] return ret, err // err = nil } hf.SetHandle(Handle) defines the called wasm function hf.Log(string) prints a value Build the wasm module: tinygo build -o hello.wasm -scheduler=none --no-debug -target wasi ./hello.go Execute the Handle function: ./capsule \\ -wasm=./hello.wasm \\ -mode=cli \\ \"\ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83\" 1234 \"Bob Morane\" -wasm flag: the path to the wasm file -mode execution mode output: - parameter is: \ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83 - parameter is: 1234 - parameter is: Bob Morane The first parameter is: \ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83 First HTTP function Create a go.mod file: ( go mod init http-say-hello ) module http-say-hello go 1.18 To serve the function through http, you need to change the signature of the Handle function: package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main() { hf.SetHandleHttp(Handle) } func Handle(request hf.Request) (response hf.Response, errResp error) { hf.Log(\"\ud83d\udcdd Body: \" + request.Body) // Read the request headers hf.Log(\"Content-Type: \" + request.Headers[\"Content-Type\"]) hf.Log(\"Content-Length: \" + request.Headers[\"Content-Length\"]) hf.Log(\"User-Agent: \" + request.Headers[\"User-Agent\"]) // Read the MESSAGE environment variable envMessage, err := hf.GetEnv(\"MESSAGE\") if err != nil { hf.Log(\"\ud83d\ude21 \" + err.Error()) } else { hf.Log(\"Environment variable: \" + envMessage) } // Set the response content type and add a message header headersResp := map[string]string{ \"Content-Type\": \"application/json; charset=utf-8\", \"Message\": \"\ud83d\udc4b hello world \ud83c\udf0d\", } jsonResponse := `{\"message\": \"hey people!\"}` return hf.Response{Body: jsonResponse, Headers: headersResp}, err } hf.SetHandleHttp(Handle) defines the called wasm function hf.Log(string) prints a value hf.GetEnv(\"MESSAGE\") get the value of the MESSAGE environment variable Build the wasm module: tinygo build -o hello.wasm -scheduler=none --no-debug -target wasi ./hello.go Serve the Handle function: export MESSAGE=\"\ud83d\udd90 good morning \ud83d\ude04\" ./capsule \\ -wasm=./hello.wasm \\ -mode=http \\ -httpPort=8080 Call the Handle function: curl -v -X POST \\ http://localhost:8080 \\ -H 'content-type: application/json; charset=utf-8' \\ -d '{\"message\": \"TinyGo \ud83d\udc9a wasm\"}' request output: > POST / HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.79.1 > Accept: */* > content-type: application/json; charset=utf-8 > Content-Length: 31 > * Mark bundle as not supporting multiuse < HTTP/1.1 200 OK < Content-Type: application/json; charset=utf-8 < Message: \ud83d\udc4b hello world \ud83c\udf0d < Date: Sat, 30 Jul 2022 19:17:28 GMT < Content-Length: 26 < {\"message\":\"hey people!\"} log server output: \ud83d\udcdd body: {\"message\":\"TinyGo \ud83d\udc9a wasm\"} Content-Type: application/json; charset=utf-8 Content-Length: 31 User-Agent: curl/7.79.1 Environment variable: \ud83d\udd90 good morning \ud83d\ude04 OnLoad function If you add an OnLoad exported function to the module, it will be executed at the start of the HTTP launcher (capsule). the main function will be executed too //export OnLoad func OnLoad() { hf.Log(\"\ud83d\udc4b from the OnLoad function\") } It can be useful to register your wasm service to a backend (Redis, CouchBase, ...) OnExit function If you add an OnExit exported function to the module, it will be executed when you stop the HTTP launcher (capsule). the main function will be executed too //export OnExit func OnExit() { hf.Log(\"\ud83d\udc4b from the OnExit function\") } It can be useful to unregister your wasm service from a backend (Redis, CouchBase, ...) GetExitError and GetExitCode function \ud83d\udd90\ud83d\udea7 it's a work in progress (it's not implemented entirely) //export OnExit func OnExit() { hf.Log(\"\ud83d\udc4b\ud83e\udd17 have a nice day\") hf.Log(\"Exit Error: \" + hf.GetExitError()) hf.Log(\"Exit Code: \" + hf.GetExitCode()) } Remote loading of the wasm module You can download the wasm module from a remote location before executing it: For example, provide the wasm file with an HTTP server, run this command at the root of your project: python3 -m http.server 9090 Now you can download the wasm file with this url: http://localhost:9090/hello.wasm Serve the Handle function: export MESSAGE=\"\ud83d\udd90 good morning \ud83d\ude04\" ./capsule \\ -url=http://localhost:9090/hello.wasm \\ -wasm=./tmp/hello.wasm \\ -mode=http \\ -httpPort=8080 -url flag: the download url -wasm flag: the path where to save the wasm file GET Request Capsule accept the GET requests, so you can serve, for example, HTML: package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main() { hf.SetHandleHttp(Handle) } func Handle(request hf.Request) (response hf.Response, errResp error) { html := ` <html> <head> <title>Wasm is fantastic \ud83d\ude0d</title> </head> <body> <h1>\ud83d\udc4b Hello World \ud83c\udf0d</h1> <h2>Served with \ud83d\udc9c with Capsule \ud83d\udc8a</h2> </body> </html> ` headersResp := map[string]string{ \"Content-Type\": \"text/html; charset=utf-8\", } return hf.Response{Body: html, Headers: headersResp}, nil } Build the wasm module: tinygo build -o hello.wasm -scheduler=none --no-debug -target wasi ./hello.go Serve the Handle \"function page\": ./capsule \\ -wasm=./hello.wasm \\ -mode=http \\ -httpPort=8080 Now, you can open http://localhost:8080 with your browser or run a curl request: curl http://localhost:8080 First Nats function \ud83d\udd90\ud83d\udea7 The NAT integration with Capsule is a work in progress and the functions are subject to change NATS is an open-source messaging system. About NATS: https://nats.io/ and https://docs.nats.io/ Nats Overview: https://docs.nats.io/nats-concepts/overview Requirements NATS Server You need to install and run a NATS server: https://docs.nats.io/running-a-nats-service/introduction/installation. Otherwise, I created a Virtual Machine for this; If you have installed Multipass , go to the ./nats/vm-nats directory of this project. I created some scripts for my experiments: create-vm.sh create the multipass VM, the settings of the VM are stored in the vm.nats.config 01-install-nats-server.sh install the NATS server inside the VM 02-start-nats-server.sh start the NATS server 03-stop-nats-server.sh stop the NATS server stop-vm.sh stop the VM start-vm.sh start the VM destroy-vm.sh delete the VM shell-vm.sh SSH connect to the VM NATS Client You need a NATS client to publish messages. You can find sample of Go and Node.js NATS clients in the ./nats/clients . Run Capsule as a NATS subscriber: capsule \\ -wasm=../wasm_modules/capsule-nats-subscriber/hello.wasm \\ -mode=nats \\ -natssrv=nats.devsecops.fun:4222 \\ -subject=ping use the \"NATS mode\": -mode=nats define the NATS subject: -subject=<subject_name> define the address of the NATS server: -natssrv=<nats_server:port> NATS function A Capsule NATS function is a subscription to a subject. Capsule is listening on a subject(like a MQTT topic) and execute a function every time a message is posted on the subject: package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main() { hf.OnNatsMessage(Handle) // define the triggered function when a message \"arrives\" on the subject/topic } // at every message on the subject channel, the `Handle` function is executed func Handle(params []string) { // send a message to another subject _, err := hf.NatsPublish(\"notify\", \"it's a wasm module here\") if err != nil { hf.Log(\"\ud83d\ude21 ouch something bad is happening\") hf.Log(err.Error()) } } Capsule NATS publisher Publish NATS messages from capsule You can use a WASM Capsule module to publish NATS messages, even if Capsule is not started in \"nats\" mode, for example from a WASM CLI Capsule module : package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main() { hf.SetHandle(Handle) } func Handle(params []string) (string, error) { var errs []string // a new connection is created at every call/publish _, err1stMsg := hf.NatsConnectPublish(\"nats.devsecops.fun:4222\", \"ping\", \"\ud83d\udd90 Hello from WASM with Nats \ud83d\udc9c\") _, err2ndMsg := hf.NatsConnectPublish(\"nats.devsecops.fun:4222\", \"notify\", \"\ud83d\udc4b Hello World \ud83c\udf0d\") if err1stMsg != nil { errs = append(errs, err1stMsg.Error()) } if err2ndMsg != nil { errs = append(errs, err2ndMsg.Error()) } return \"NATS Rocks!\", errors.New(strings.Join(errs, \"|\")) } In this use case, you need to define the NATS server and create a connection Request and Reply A NATS \"publisher\" can make a request to a NATS \"subscriber\" and wait for an answer package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main() { hf.SetHandle(Handle) } func Handle(params []string) (string, error) { // Publish and wait for an answer; 1 is the timeout in seconds res, err := hf.NatsConnectRequest(\"nats.devsecops.fun:4222\", \"notify\", \"\ud83d\udc4b Hello World \ud83c\udf0d\", 1) if err != nil { hf.Log(\"\ud83d\udd34\" + err.Error()) } else { // Display the answer hf.Log(\"\ud83d\udd35\" + res) } return \"NATS Rocks!\", err } A NATS \"subscriber\" can reply to a request received on its subject package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main() { hf.OnNatsMessage(Handle) } func Handle(params []string) { hf.Log(\"Message on subject: \" + hf.NatsGetSubject() + \", \ud83c\udf89 message: \" + params[0]) // reply to the message on the current subject; 10 is the timeout in seconds _, _ = hf.NatsReply(\"Hey! What's up\", 10) } First MQTT function \ud83d\udd90\ud83d\udea7 The MQTT integration with Capsule is a work in progress and the functions are subject to change MQTT is a standard for IOT message. About MQTT: https://mqtt.org/ Requirements MQTT Server You need to install and run a MQTT server. To do so, go to the ./mqtt directory of this project and run the docker-compose file Run Capsule as a MQTT subscriber: capsule \\ -wasm=../wasm_modules/capsule-mqtt-subscriber/hello.wasm \\ -mode=mqtt \\ -mqttsrv=127.0.0.1:1883 \\ -topic=topic/sensor0 \\ -clientId=sensor use the \"MQTT mode\": -mode=mqtt define the MQTT topic: -topic=<topic_name> define the MQTT clientId: -clientId=<clientId> define the address of the MQTT server: -mqttsrv=<mqtt_server:port> MQTT function A Capsule MQTT function is a subscription to a subject. Capsule is listening on a topic and execute a function every time a message is posted on the subject: package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main() { hf.OnMqttMessage(Handle) // define the triggered function when a message \"arrives\" on the topic } // at every message on the subject channel, the `Handle` function is executed func Handle(params []string) { // send a message to another subject _, err := hf.MqttPublish(\"topic/reply\", \"it's a wasm module here\") if err != nil { hf.Log(\"\ud83d\ude21 ouch something bad is happening\") hf.Log(err.Error()) } } Capsule MQTT publisher Publish MQTT messages from capsule You can use a WASM Capsule module to MQTT messages, even if Capsule is not started in \"mqtt\" mode, for example from a WASM CLI Capsule module : package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main() { hf.SetHandle(Handle) } func Handle(params []string) (string, error) { var errs []string // a new connection is created at every call/publish _, err1stMsg := hf.MqttConnectPublish(\"127.0.0.1:1883\", \"sensor\", \"topic/sensor1\", \"\ud83d\udd90 Hello from WASM with MQTT \ud83d\udc9c\") _, err2ndMsg := hf.MqttConnectPublish(\"127.0.0.1:1883\", \"sensor\", \"topic/sensor2\", \"\ud83d\udc4b Hello World \ud83c\udf0d\") if err1stMsg != nil { errs = append(errs, err1stMsg.Error()) } if err2ndMsg != nil { errs = append(errs, err2ndMsg.Error()) } return \"MQTT Rocks!\", errors.New(strings.Join(errs, \"|\")) } In this use case, you need to define the MQTT server and create a connection","title":"Developer guide"},{"location":"dev-guide/#developer-guide","text":"","title":"Developer Guide"},{"location":"dev-guide/#first-cli-function","text":"Create a go.mod file: ( go mod init cli-say-hello ) module cli-say-hello go 1.18 Install the Capsule dependencies: go get github.com/bots-garden/capsule/capsulemodule/hostfunctions Create a hello.go file: package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main() { hf.SetHandle(Handle) } func Handle(params []string) (string, error) { var err error for _, param := range params { hf.Log(\"- parameter is: \" + param) } ret := \"The first parameter is: \" + params[0] return ret, err // err = nil } hf.SetHandle(Handle) defines the called wasm function hf.Log(string) prints a value Build the wasm module: tinygo build -o hello.wasm -scheduler=none --no-debug -target wasi ./hello.go Execute the Handle function: ./capsule \\ -wasm=./hello.wasm \\ -mode=cli \\ \"\ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83\" 1234 \"Bob Morane\" -wasm flag: the path to the wasm file -mode execution mode output: - parameter is: \ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83 - parameter is: 1234 - parameter is: Bob Morane The first parameter is: \ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83","title":"First CLI function"},{"location":"dev-guide/#first-http-function","text":"Create a go.mod file: ( go mod init http-say-hello ) module http-say-hello go 1.18 To serve the function through http, you need to change the signature of the Handle function: package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main() { hf.SetHandleHttp(Handle) } func Handle(request hf.Request) (response hf.Response, errResp error) { hf.Log(\"\ud83d\udcdd Body: \" + request.Body) // Read the request headers hf.Log(\"Content-Type: \" + request.Headers[\"Content-Type\"]) hf.Log(\"Content-Length: \" + request.Headers[\"Content-Length\"]) hf.Log(\"User-Agent: \" + request.Headers[\"User-Agent\"]) // Read the MESSAGE environment variable envMessage, err := hf.GetEnv(\"MESSAGE\") if err != nil { hf.Log(\"\ud83d\ude21 \" + err.Error()) } else { hf.Log(\"Environment variable: \" + envMessage) } // Set the response content type and add a message header headersResp := map[string]string{ \"Content-Type\": \"application/json; charset=utf-8\", \"Message\": \"\ud83d\udc4b hello world \ud83c\udf0d\", } jsonResponse := `{\"message\": \"hey people!\"}` return hf.Response{Body: jsonResponse, Headers: headersResp}, err } hf.SetHandleHttp(Handle) defines the called wasm function hf.Log(string) prints a value hf.GetEnv(\"MESSAGE\") get the value of the MESSAGE environment variable Build the wasm module: tinygo build -o hello.wasm -scheduler=none --no-debug -target wasi ./hello.go Serve the Handle function: export MESSAGE=\"\ud83d\udd90 good morning \ud83d\ude04\" ./capsule \\ -wasm=./hello.wasm \\ -mode=http \\ -httpPort=8080 Call the Handle function: curl -v -X POST \\ http://localhost:8080 \\ -H 'content-type: application/json; charset=utf-8' \\ -d '{\"message\": \"TinyGo \ud83d\udc9a wasm\"}' request output: > POST / HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.79.1 > Accept: */* > content-type: application/json; charset=utf-8 > Content-Length: 31 > * Mark bundle as not supporting multiuse < HTTP/1.1 200 OK < Content-Type: application/json; charset=utf-8 < Message: \ud83d\udc4b hello world \ud83c\udf0d < Date: Sat, 30 Jul 2022 19:17:28 GMT < Content-Length: 26 < {\"message\":\"hey people!\"} log server output: \ud83d\udcdd body: {\"message\":\"TinyGo \ud83d\udc9a wasm\"} Content-Type: application/json; charset=utf-8 Content-Length: 31 User-Agent: curl/7.79.1 Environment variable: \ud83d\udd90 good morning \ud83d\ude04","title":"First HTTP function"},{"location":"dev-guide/#onload-function","text":"If you add an OnLoad exported function to the module, it will be executed at the start of the HTTP launcher (capsule). the main function will be executed too //export OnLoad func OnLoad() { hf.Log(\"\ud83d\udc4b from the OnLoad function\") } It can be useful to register your wasm service to a backend (Redis, CouchBase, ...)","title":"OnLoad function"},{"location":"dev-guide/#onexit-function","text":"If you add an OnExit exported function to the module, it will be executed when you stop the HTTP launcher (capsule). the main function will be executed too //export OnExit func OnExit() { hf.Log(\"\ud83d\udc4b from the OnExit function\") } It can be useful to unregister your wasm service from a backend (Redis, CouchBase, ...)","title":"OnExit function"},{"location":"dev-guide/#getexiterror-and-getexitcode-function","text":"\ud83d\udd90\ud83d\udea7 it's a work in progress (it's not implemented entirely) //export OnExit func OnExit() { hf.Log(\"\ud83d\udc4b\ud83e\udd17 have a nice day\") hf.Log(\"Exit Error: \" + hf.GetExitError()) hf.Log(\"Exit Code: \" + hf.GetExitCode()) }","title":"GetExitError and GetExitCode function"},{"location":"dev-guide/#remote-loading-of-the-wasm-module","text":"You can download the wasm module from a remote location before executing it: For example, provide the wasm file with an HTTP server, run this command at the root of your project: python3 -m http.server 9090 Now you can download the wasm file with this url: http://localhost:9090/hello.wasm Serve the Handle function: export MESSAGE=\"\ud83d\udd90 good morning \ud83d\ude04\" ./capsule \\ -url=http://localhost:9090/hello.wasm \\ -wasm=./tmp/hello.wasm \\ -mode=http \\ -httpPort=8080 -url flag: the download url -wasm flag: the path where to save the wasm file","title":"Remote loading of the wasm module"},{"location":"dev-guide/#get-request","text":"Capsule accept the GET requests, so you can serve, for example, HTML: package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main() { hf.SetHandleHttp(Handle) } func Handle(request hf.Request) (response hf.Response, errResp error) { html := ` <html> <head> <title>Wasm is fantastic \ud83d\ude0d</title> </head> <body> <h1>\ud83d\udc4b Hello World \ud83c\udf0d</h1> <h2>Served with \ud83d\udc9c with Capsule \ud83d\udc8a</h2> </body> </html> ` headersResp := map[string]string{ \"Content-Type\": \"text/html; charset=utf-8\", } return hf.Response{Body: html, Headers: headersResp}, nil } Build the wasm module: tinygo build -o hello.wasm -scheduler=none --no-debug -target wasi ./hello.go Serve the Handle \"function page\": ./capsule \\ -wasm=./hello.wasm \\ -mode=http \\ -httpPort=8080 Now, you can open http://localhost:8080 with your browser or run a curl request: curl http://localhost:8080","title":"GET Request"},{"location":"dev-guide/#first-nats-function","text":"\ud83d\udd90\ud83d\udea7 The NAT integration with Capsule is a work in progress and the functions are subject to change NATS is an open-source messaging system. About NATS: https://nats.io/ and https://docs.nats.io/ Nats Overview: https://docs.nats.io/nats-concepts/overview","title":"First Nats function"},{"location":"dev-guide/#requirements","text":"","title":"Requirements"},{"location":"dev-guide/#nats-server","text":"You need to install and run a NATS server: https://docs.nats.io/running-a-nats-service/introduction/installation. Otherwise, I created a Virtual Machine for this; If you have installed Multipass , go to the ./nats/vm-nats directory of this project. I created some scripts for my experiments: create-vm.sh create the multipass VM, the settings of the VM are stored in the vm.nats.config 01-install-nats-server.sh install the NATS server inside the VM 02-start-nats-server.sh start the NATS server 03-stop-nats-server.sh stop the NATS server stop-vm.sh stop the VM start-vm.sh start the VM destroy-vm.sh delete the VM shell-vm.sh SSH connect to the VM","title":"NATS Server"},{"location":"dev-guide/#nats-client","text":"You need a NATS client to publish messages. You can find sample of Go and Node.js NATS clients in the ./nats/clients .","title":"NATS Client"},{"location":"dev-guide/#run-capsule-as-a-nats-subscriber","text":"capsule \\ -wasm=../wasm_modules/capsule-nats-subscriber/hello.wasm \\ -mode=nats \\ -natssrv=nats.devsecops.fun:4222 \\ -subject=ping use the \"NATS mode\": -mode=nats define the NATS subject: -subject=<subject_name> define the address of the NATS server: -natssrv=<nats_server:port>","title":"Run Capsule as a NATS subscriber:"},{"location":"dev-guide/#nats-function","text":"A Capsule NATS function is a subscription to a subject. Capsule is listening on a subject(like a MQTT topic) and execute a function every time a message is posted on the subject: package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main() { hf.OnNatsMessage(Handle) // define the triggered function when a message \"arrives\" on the subject/topic } // at every message on the subject channel, the `Handle` function is executed func Handle(params []string) { // send a message to another subject _, err := hf.NatsPublish(\"notify\", \"it's a wasm module here\") if err != nil { hf.Log(\"\ud83d\ude21 ouch something bad is happening\") hf.Log(err.Error()) } }","title":"NATS function"},{"location":"dev-guide/#capsule-nats-publisher","text":"Publish NATS messages from capsule You can use a WASM Capsule module to publish NATS messages, even if Capsule is not started in \"nats\" mode, for example from a WASM CLI Capsule module : package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main() { hf.SetHandle(Handle) } func Handle(params []string) (string, error) { var errs []string // a new connection is created at every call/publish _, err1stMsg := hf.NatsConnectPublish(\"nats.devsecops.fun:4222\", \"ping\", \"\ud83d\udd90 Hello from WASM with Nats \ud83d\udc9c\") _, err2ndMsg := hf.NatsConnectPublish(\"nats.devsecops.fun:4222\", \"notify\", \"\ud83d\udc4b Hello World \ud83c\udf0d\") if err1stMsg != nil { errs = append(errs, err1stMsg.Error()) } if err2ndMsg != nil { errs = append(errs, err2ndMsg.Error()) } return \"NATS Rocks!\", errors.New(strings.Join(errs, \"|\")) } In this use case, you need to define the NATS server and create a connection","title":"Capsule NATS publisher"},{"location":"dev-guide/#request-and-reply","text":"A NATS \"publisher\" can make a request to a NATS \"subscriber\" and wait for an answer package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main() { hf.SetHandle(Handle) } func Handle(params []string) (string, error) { // Publish and wait for an answer; 1 is the timeout in seconds res, err := hf.NatsConnectRequest(\"nats.devsecops.fun:4222\", \"notify\", \"\ud83d\udc4b Hello World \ud83c\udf0d\", 1) if err != nil { hf.Log(\"\ud83d\udd34\" + err.Error()) } else { // Display the answer hf.Log(\"\ud83d\udd35\" + res) } return \"NATS Rocks!\", err } A NATS \"subscriber\" can reply to a request received on its subject package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main() { hf.OnNatsMessage(Handle) } func Handle(params []string) { hf.Log(\"Message on subject: \" + hf.NatsGetSubject() + \", \ud83c\udf89 message: \" + params[0]) // reply to the message on the current subject; 10 is the timeout in seconds _, _ = hf.NatsReply(\"Hey! What's up\", 10) }","title":"Request and Reply"},{"location":"dev-guide/#first-mqtt-function","text":"\ud83d\udd90\ud83d\udea7 The MQTT integration with Capsule is a work in progress and the functions are subject to change MQTT is a standard for IOT message. About MQTT: https://mqtt.org/","title":"First MQTT function"},{"location":"dev-guide/#requirements_1","text":"","title":"Requirements"},{"location":"dev-guide/#mqtt-server","text":"You need to install and run a MQTT server. To do so, go to the ./mqtt directory of this project and run the docker-compose file","title":"MQTT Server"},{"location":"dev-guide/#run-capsule-as-a-mqtt-subscriber","text":"capsule \\ -wasm=../wasm_modules/capsule-mqtt-subscriber/hello.wasm \\ -mode=mqtt \\ -mqttsrv=127.0.0.1:1883 \\ -topic=topic/sensor0 \\ -clientId=sensor use the \"MQTT mode\": -mode=mqtt define the MQTT topic: -topic=<topic_name> define the MQTT clientId: -clientId=<clientId> define the address of the MQTT server: -mqttsrv=<mqtt_server:port>","title":"Run Capsule as a MQTT subscriber:"},{"location":"dev-guide/#mqtt-function","text":"A Capsule MQTT function is a subscription to a subject. Capsule is listening on a topic and execute a function every time a message is posted on the subject: package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main() { hf.OnMqttMessage(Handle) // define the triggered function when a message \"arrives\" on the topic } // at every message on the subject channel, the `Handle` function is executed func Handle(params []string) { // send a message to another subject _, err := hf.MqttPublish(\"topic/reply\", \"it's a wasm module here\") if err != nil { hf.Log(\"\ud83d\ude21 ouch something bad is happening\") hf.Log(err.Error()) } }","title":"MQTT function"},{"location":"dev-guide/#capsule-mqtt-publisher","text":"Publish MQTT messages from capsule You can use a WASM Capsule module to MQTT messages, even if Capsule is not started in \"mqtt\" mode, for example from a WASM CLI Capsule module : package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main() { hf.SetHandle(Handle) } func Handle(params []string) (string, error) { var errs []string // a new connection is created at every call/publish _, err1stMsg := hf.MqttConnectPublish(\"127.0.0.1:1883\", \"sensor\", \"topic/sensor1\", \"\ud83d\udd90 Hello from WASM with MQTT \ud83d\udc9c\") _, err2ndMsg := hf.MqttConnectPublish(\"127.0.0.1:1883\", \"sensor\", \"topic/sensor2\", \"\ud83d\udc4b Hello World \ud83c\udf0d\") if err1stMsg != nil { errs = append(errs, err1stMsg.Error()) } if err2ndMsg != nil { errs = append(errs, err2ndMsg.Error()) } return \"MQTT Rocks!\", errors.New(strings.Join(errs, \"|\")) } In this use case, you need to define the MQTT server and create a connection","title":"Capsule MQTT publisher"},{"location":"host-functions/","text":"Host functions Capsule offers some capabilities to the wasm modules by providing some \"host functions\": Print a message hf.Log(\"\ud83d\udc4b Hello World \ud83c\udf0d\") Read and Write files txt, err := hf.ReadFile(\"about.txt\") if err != nil { hf.Log(err.Error()) } hf.Log(txt) newFile, err := hf.WriteFile(\"hello.txt\", \"\ud83d\udc4b HELLO WORLD \ud83c\udf0d\") if err != nil { hf.Log(err.Error()) } hf.Log(newFile) Read value of the environment variables message, err := hf.GetEnv(\"MESSAGE\") if err != nil { hf.Log(err.Error()) } else { hf.Log(\"MESSAGE=\" + message) } Make HTTP requests GET ret, err := hf.Http(\"https://httpbin.org/get\", \"GET\", headers, \"\") if err != nil { hf.Log(\"\ud83d\ude21 error:\" + err.Error()) } else { hf.Log(\"\ud83d\udcddresult: \" + ret) } POST headers := map[string]string{\"Accept\": \"application/json\", \"Content-Type\": \"text/html; charset=UTF-8\"} ret, err := hf.Http(\"https://httpbin.org/post\", \"POST\", headers, \"\ud83d\udc4b hello world \ud83c\udf0d\") if err != nil { hf.Log(\"\ud83d\ude21 error:\" + err.Error()) } else { hf.Log(\"\ud83d\udcddresult: \" + ret) } Use memory cache MemorySet _, err := hf.MemorySet(\"message\", \"\ud83d\ude80 hello is started\") MemoryGet value, err := hf.MemoryGet(\"message\") MemoryKeys keys, err := hf.MemoryKeys() // it will return an array of strings if err != nil { hf.Log(err.Error()) } for key, value := range keys { hf.Log(key+\":\"+value) } Make Redis queries \ud83d\udea7 this is a work in progress You need to run Capsule with these two environment variables: REDIS_ADDR=\"localhost:6379\" REDIS_PWD=\"\" SET // add a key, value res, err := hf.RedisSet(\"greetings\", \"Hello World\") if err != nil { hf.Log(err.Error()) } else { hf.Log(\"Value: \" + res) } GET // read the value res, err := hf.RedisGet(\"greetings\") if err != nil { hf.Log(err.Error()) } else { hf.Log(\"Value: \" + res) } KEYS legion, err := hf.RedisKeys(\"bob*\") if err != nil { hf.Log(err.Error()) } for _, bob := range legion { hf.Log(bob) } Make CouchBase N1QL Query You need to run Capsule with these four environment variables: COUCHBASE_CLUSTER=\"couchbase://localhost\" COUCHBASE_USER=\"admin\" COUCHBASE_PWD=\"ilovepandas\" COUCHBASE_BUCKET=\"wasm-data\" bucketName, _ := hf.GetEnv(\"COUCHBASE_BUCKET\") query := \"SELECT * FROM `\" + bucketName + \"`.data.docs\" jsonStringArray, err := hf.CouchBaseQuery(query) Nats NatsPublish(subject string, message string) : publish a message on a subject _, err := hf.NatsPublish(\"notify\", \"it's a wasm module here\") You must use the \"nats\" mode of Capsule as the NATS connection is defined at the start of Capsule and shared with the WASM module: capsule \\ -wasm=../wasm_modules/capsule-nats-subscriber/hello.wasm \\ -mode=nats \\ -natssrv=nats.devsecops.fun:4222 \\ -subject=ping NatsReply(message string, timeout uint32) : publish a message on the current subject and wait for an answer _, err := hf.NatsReply(\"it's a wasm module here\", 10) You must use the \"nats\" mode of Capsule as the NATS connection and the subscription are defined at the start of Capsule and shared with the WASM module. NatsGetSubject() : get the subject listened by the Capsule launcher hf.Log(\"\ud83d\udc42Listening on: \" + hf.NatsGetSubject()) NatsGetServer() : get the connected NATS server hf.Log(\"\ud83d\udc4b NATS server: \" + hf.NatsGetServer()) NatsConnectPublish(server string, subject string, message string) : connect to a NATS server and send a message on a subject _, err := hf.NatsConnectPublish(\"nats.devsecops.fun:4222\", \"ping\", \"\ud83d\udd90 Hello from WASM with Nats \ud83d\udc9c\") You can use this function with all the running modes of Capsule NatsConnectPublish(server string, subject string, message string, timeout uint32) : connect to a NATS server and send a message on a subject answer, err := hf.NatsConnectRequest(\"nats.devsecops.fun:4222\", \"notify\", \"\ud83d\udc4b Hello World \ud83c\udf0d\", 1) You can use this function with all the running modes of Capsule Error Management \ud83d\udd90\ud83d\udd90\ud83d\udd90 \ud83d\udea7 it's a work in progress (it's not implemented entirely) GetExitError() & GetExitCode : //export OnExit func OnExit() { hf.Log(\"\ud83d\udc4b\ud83e\udd17 have a nice day\") hf.Log(\"Exit Error: \" + hf.GetExitError()) hf.Log(\"Exit Code: \" + hf.GetExitCode()) }","title":"Host functions"},{"location":"host-functions/#host-functions","text":"Capsule offers some capabilities to the wasm modules by providing some \"host functions\":","title":"Host functions"},{"location":"host-functions/#print-a-message","text":"hf.Log(\"\ud83d\udc4b Hello World \ud83c\udf0d\")","title":"Print a message"},{"location":"host-functions/#read-and-write-files","text":"txt, err := hf.ReadFile(\"about.txt\") if err != nil { hf.Log(err.Error()) } hf.Log(txt) newFile, err := hf.WriteFile(\"hello.txt\", \"\ud83d\udc4b HELLO WORLD \ud83c\udf0d\") if err != nil { hf.Log(err.Error()) } hf.Log(newFile)","title":"Read and Write files"},{"location":"host-functions/#read-value-of-the-environment-variables","text":"message, err := hf.GetEnv(\"MESSAGE\") if err != nil { hf.Log(err.Error()) } else { hf.Log(\"MESSAGE=\" + message) }","title":"Read value of the environment variables"},{"location":"host-functions/#make-http-requests","text":"GET ret, err := hf.Http(\"https://httpbin.org/get\", \"GET\", headers, \"\") if err != nil { hf.Log(\"\ud83d\ude21 error:\" + err.Error()) } else { hf.Log(\"\ud83d\udcddresult: \" + ret) } POST headers := map[string]string{\"Accept\": \"application/json\", \"Content-Type\": \"text/html; charset=UTF-8\"} ret, err := hf.Http(\"https://httpbin.org/post\", \"POST\", headers, \"\ud83d\udc4b hello world \ud83c\udf0d\") if err != nil { hf.Log(\"\ud83d\ude21 error:\" + err.Error()) } else { hf.Log(\"\ud83d\udcddresult: \" + ret) }","title":"Make HTTP requests"},{"location":"host-functions/#use-memory-cache","text":"MemorySet _, err := hf.MemorySet(\"message\", \"\ud83d\ude80 hello is started\") MemoryGet value, err := hf.MemoryGet(\"message\") MemoryKeys keys, err := hf.MemoryKeys() // it will return an array of strings if err != nil { hf.Log(err.Error()) } for key, value := range keys { hf.Log(key+\":\"+value) }","title":"Use memory cache"},{"location":"host-functions/#make-redis-queries","text":"\ud83d\udea7 this is a work in progress You need to run Capsule with these two environment variables: REDIS_ADDR=\"localhost:6379\" REDIS_PWD=\"\" SET // add a key, value res, err := hf.RedisSet(\"greetings\", \"Hello World\") if err != nil { hf.Log(err.Error()) } else { hf.Log(\"Value: \" + res) } GET // read the value res, err := hf.RedisGet(\"greetings\") if err != nil { hf.Log(err.Error()) } else { hf.Log(\"Value: \" + res) } KEYS legion, err := hf.RedisKeys(\"bob*\") if err != nil { hf.Log(err.Error()) } for _, bob := range legion { hf.Log(bob) }","title":"Make Redis queries"},{"location":"host-functions/#make-couchbase-n1ql-query","text":"You need to run Capsule with these four environment variables: COUCHBASE_CLUSTER=\"couchbase://localhost\" COUCHBASE_USER=\"admin\" COUCHBASE_PWD=\"ilovepandas\" COUCHBASE_BUCKET=\"wasm-data\" bucketName, _ := hf.GetEnv(\"COUCHBASE_BUCKET\") query := \"SELECT * FROM `\" + bucketName + \"`.data.docs\" jsonStringArray, err := hf.CouchBaseQuery(query)","title":"Make CouchBase N1QL Query"},{"location":"host-functions/#nats","text":"NatsPublish(subject string, message string) : publish a message on a subject _, err := hf.NatsPublish(\"notify\", \"it's a wasm module here\") You must use the \"nats\" mode of Capsule as the NATS connection is defined at the start of Capsule and shared with the WASM module: capsule \\ -wasm=../wasm_modules/capsule-nats-subscriber/hello.wasm \\ -mode=nats \\ -natssrv=nats.devsecops.fun:4222 \\ -subject=ping NatsReply(message string, timeout uint32) : publish a message on the current subject and wait for an answer _, err := hf.NatsReply(\"it's a wasm module here\", 10) You must use the \"nats\" mode of Capsule as the NATS connection and the subscription are defined at the start of Capsule and shared with the WASM module. NatsGetSubject() : get the subject listened by the Capsule launcher hf.Log(\"\ud83d\udc42Listening on: \" + hf.NatsGetSubject()) NatsGetServer() : get the connected NATS server hf.Log(\"\ud83d\udc4b NATS server: \" + hf.NatsGetServer()) NatsConnectPublish(server string, subject string, message string) : connect to a NATS server and send a message on a subject _, err := hf.NatsConnectPublish(\"nats.devsecops.fun:4222\", \"ping\", \"\ud83d\udd90 Hello from WASM with Nats \ud83d\udc9c\") You can use this function with all the running modes of Capsule NatsConnectPublish(server string, subject string, message string, timeout uint32) : connect to a NATS server and send a message on a subject answer, err := hf.NatsConnectRequest(\"nats.devsecops.fun:4222\", \"notify\", \"\ud83d\udc4b Hello World \ud83c\udf0d\", 1) You can use this function with all the running modes of Capsule","title":"Nats"},{"location":"host-functions/#error-management","text":"\ud83d\udd90\ud83d\udd90\ud83d\udd90 \ud83d\udea7 it's a work in progress (it's not implemented entirely) GetExitError() & GetExitCode : //export OnExit func OnExit() { hf.Log(\"\ud83d\udc4b\ud83e\udd17 have a nice day\") hf.Log(\"Exit Error: \" + hf.GetExitError()) hf.Log(\"Exit Code: \" + hf.GetExitCode()) }","title":"Error Management"},{"location":"install/","text":"Installing Capsule Before executing or running a function, you need to install the last release of Capsule : CAPSULE_VERSION=\"v0.2.8\" wget -O - https://raw.githubusercontent.com/bots-garden/capsule/${CAPSULE_VERSION}/install-capsule-launcher.sh| bash The script will install capsule in $HOME/.local/bin \ud83d\udd90 On macOS : create the $HOME/.local/bin directory add it to your path: export CAPSULE_PATH=\"$HOME/.local\" export PATH=\"$CAPSULE_PATH/bin:$PATH\" if you want to install Capsule somewhere else, override the CAPSULE_PATH variable (default value: CAPSULE_PATH=\"$HOME/.local/bin\" ) Then you can serve a wasm function like this: MESSAGE=\"\ud83d\udc4b Hello World \ud83c\udf0d\" capsule \\ -wasm=./app/index.wasm \\ -mode=http \\ -httpPort=8080 You can download the appropriate release of Capsule here: v0.2.8 \ud83e\udda4 [dodo] Using the Capsule Docker image The documentation is a wip \ud83d\udea7 A \"scratch\" Docker image of Capsule exists on https://hub.docker.com/r/k33g/capsule-launcher/tags . You can find more details on the capsule-docker-image project. This image will be used to deploy Capsule to CaaS or Kubernetes. You can use it directly to run a wasm function without installing Capsule: docker run \\ -p 8080:8080 \\ -e MESSAGE=\"\ud83d\udc4b Hello World \ud83c\udf0d\" \\ -v $(pwd):/app --rm k33g/capsule-launcher:0.2.8 \\ /capsule \\ -wasm=./app/index.wasm \\ -mode=http \\ -httpPort=8080 \ud83d\udc4b You will find some running examples with these projects: https://github.com/bots-garden/capsule-launcher-demo https://github.com/bots-garden/capsule-hello-universe Old samples to be updated: https://github.com/bots-garden/capsule-samples https://github.com/bots-garden/capsule-on-fly-dot-io","title":"Install"},{"location":"install/#installing-capsule","text":"Before executing or running a function, you need to install the last release of Capsule : CAPSULE_VERSION=\"v0.2.8\" wget -O - https://raw.githubusercontent.com/bots-garden/capsule/${CAPSULE_VERSION}/install-capsule-launcher.sh| bash The script will install capsule in $HOME/.local/bin \ud83d\udd90 On macOS : create the $HOME/.local/bin directory add it to your path: export CAPSULE_PATH=\"$HOME/.local\" export PATH=\"$CAPSULE_PATH/bin:$PATH\" if you want to install Capsule somewhere else, override the CAPSULE_PATH variable (default value: CAPSULE_PATH=\"$HOME/.local/bin\" ) Then you can serve a wasm function like this: MESSAGE=\"\ud83d\udc4b Hello World \ud83c\udf0d\" capsule \\ -wasm=./app/index.wasm \\ -mode=http \\ -httpPort=8080 You can download the appropriate release of Capsule here: v0.2.8 \ud83e\udda4 [dodo]","title":"Installing Capsule"},{"location":"install/#using-the-capsule-docker-image","text":"The documentation is a wip \ud83d\udea7 A \"scratch\" Docker image of Capsule exists on https://hub.docker.com/r/k33g/capsule-launcher/tags . You can find more details on the capsule-docker-image project. This image will be used to deploy Capsule to CaaS or Kubernetes. You can use it directly to run a wasm function without installing Capsule: docker run \\ -p 8080:8080 \\ -e MESSAGE=\"\ud83d\udc4b Hello World \ud83c\udf0d\" \\ -v $(pwd):/app --rm k33g/capsule-launcher:0.2.8 \\ /capsule \\ -wasm=./app/index.wasm \\ -mode=http \\ -httpPort=8080 \ud83d\udc4b You will find some running examples with these projects: https://github.com/bots-garden/capsule-launcher-demo https://github.com/bots-garden/capsule-hello-universe Old samples to be updated: https://github.com/bots-garden/capsule-samples https://github.com/bots-garden/capsule-on-fly-dot-io","title":"Using the Capsule Docker image"},{"location":"references/","text":"References Blog posts Create a GitLab bot with a Capsule Wasm function in less than 100 lines of code Deploy Capsule Functions on Fly.io in a flash A simple calc serverless function with Capsule, NATS and Node.js Host and Serve a Lit SPA with WebAssembly (and Capsule) Capsule, my personal wasm FaaS (part 2) Capsule, my personal wasm multi-tools knife (part 1) Extend Wasm with host functions thanks to Wazero An essay on the bi-directional exchange of strings between the Wasm module (with TinyGo) and Node.js (with WASI support)","title":"Refs"},{"location":"references/#references","text":"","title":"References"},{"location":"references/#blog-posts","text":"Create a GitLab bot with a Capsule Wasm function in less than 100 lines of code Deploy Capsule Functions on Fly.io in a flash A simple calc serverless function with Capsule, NATS and Node.js Host and Serve a Lit SPA with WebAssembly (and Capsule) Capsule, my personal wasm FaaS (part 2) Capsule, my personal wasm multi-tools knife (part 1) Extend Wasm with host functions thanks to Wazero An essay on the bi-directional exchange of strings between the Wasm module (with TinyGo) and Node.js (with WASI support)","title":"Blog posts"},{"location":"tooling/","text":"Tooling The documentation is a wip \ud83d\udea7 To write and build wasm function for Capsule, you need to install GoLang and TinyGo. Otherwise, you can use the capsule-function-builder project. It provides a very simple CLI, named capsule-builder or cabu that uses a Docker image with all the necessary resources (Golang and TinyGo compilers). Install Capsule Builder CAPSULE_BUILDER_VERSION=\"v0.0.2\" wget -O - https://raw.githubusercontent.com/bots-garden/capsule-function-builder/${CAPSULE_BUILDER_VERSION}/install-capsule-builder.sh | bash Then you can generate a new project from a template: # template name: `service-get` # function project name `hello-world` cabu generate service-get hello-world Then, build it easily: cd hello-world cabu build . hello-world.go hello-world.wasm And, finally, serve it: capsule \\ -wasm=./hello-world.wasm \\ -mode=http \\ -httpPort=8080","title":"Tooling"},{"location":"tooling/#tooling","text":"The documentation is a wip \ud83d\udea7 To write and build wasm function for Capsule, you need to install GoLang and TinyGo. Otherwise, you can use the capsule-function-builder project. It provides a very simple CLI, named capsule-builder or cabu that uses a Docker image with all the necessary resources (Golang and TinyGo compilers).","title":"Tooling"},{"location":"tooling/#install-capsule-builder","text":"CAPSULE_BUILDER_VERSION=\"v0.0.2\" wget -O - https://raw.githubusercontent.com/bots-garden/capsule-function-builder/${CAPSULE_BUILDER_VERSION}/install-capsule-builder.sh | bash Then you can generate a new project from a template: # template name: `service-get` # function project name `hello-world` cabu generate service-get hello-world Then, build it easily: cd hello-world cabu build . hello-world.go hello-world.wasm And, finally, serve it: capsule \\ -wasm=./hello-world.wasm \\ -mode=http \\ -httpPort=8080","title":"Install Capsule Builder"}]}