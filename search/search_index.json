{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Capsule: the nano (wasm) functions runner What is Capsule ? Capsule is a WebAssembly Function Runner . It means that Capsule is both: An HTTP server that serves WebAssembly functions A NATS subscriber and publisher (written with WebAssembly) A MQTT subscriber and publisher (written with WebAssembly) A CLI , you can simply execute a WASM function in a terminal Capsule is developed with GoLang and thanks to the \ud83d\udc9c Wazero project The wasm modules are developed in GoLang and compiled with TinyGo \ud83d\udc9c (with the WASI specification) What does a WASM function look like with Capsule? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . SetHandleHttp ( Handle ) } func Handle ( request hf . Request ) ( response hf . Response , errResp error ) { headersResp := map [ string ] string { \"Content-Type\" : \"application/json; charset=utf-8\" , } jsondoc := `{\"message\": \"\ud83d\udc4b Hello World \ud83c\udf0d\"}` return hf . Response { Body : jsondoc , Headers : headersResp }, err } What are the added values of Capsule? Capsule brings superpowers to the WASM functions Thanks to host functions provided by Capsule , the WASM functions can: Description Host function Print a message to the console hf.Log(string) Read files hf.ReadFile(\"about.txt\") Write files hf.WriteFile(\"hello.txt\", \"\ud83d\udc4b HELLO WORLD \ud83c\udf0d\") Read value of the environment variables hf.GetEnv(\"MESSAGE\") Make HTTP requests hf.Http(\"https://httpbin.org/post\", \"POST\", headers, \"\ud83d\udc4b hello world \ud83c\udf0d\") Use memory cache (set) hf.MemorySet(\"message\", \"\ud83d\ude80 hello is started\") hf.MemoryGet(\"message\") Make Redis queries hf.RedisSet(\"greetings\", \"Hello World\") hf.RedisGet(\"greetings\") hf.RedisKeys(\"bob*\") Make CouchBase N1QL Query jsonStringArray, err := hf.CouchBaseQuery(query) Use Nats hf.NatsPublish(\"subject\", \"hello\") hf.NatsReply(\"it's a wasm module here\", 10) hf.NatsGetSubject() hf.NatsGetServer() hf.NatsConnectPublish(\"nats.devsecops.fun:4222\", \"subject\", \"\ud83d\udd90 Hello from WASM with Nats \ud83d\udc9c\") hf.NatsConnectRequest(\"nats.devsecops.fun:4222\", \"subject\", \"\ud83d\udc4b Hello World \ud83c\udf0d\", 1) Use MQTT hf.MqttConnectPublish(\"127.0.0.1:1883\", \"sensor_id0\", \"topic\", \"\ud83d\udc4b Hello World \ud83c\udf0d\") hf.MqttGetTopic() hf.MqttPublish(\"topic\", \"it's a wasm module here\") Manage Errors \ud83d\udd90 \ud83d\udea7 it's a work in progress hf.GetExitError() hf.GetExitCode() Information Label Description Issues https://github.com/bots-garden/capsule/issues Last release v0.2.8 \ud83e\udda4 [dodo] Dev release v0.2.9 \ud83e\udd9c [parrot] \ud83d\udea7 in progress Releases https://github.com/bots-garden/capsule/releases What's new v0.2.8 : Capsule uses now Fiber instead Gin . The size of the Capsule Runner Docker image is now 16.8M!","title":"Home"},{"location":"#capsule-the-nano-wasm-functions-runner","text":"","title":"Capsule: the nano (wasm) functions runner"},{"location":"#what-is-capsule","text":"Capsule is a WebAssembly Function Runner . It means that Capsule is both: An HTTP server that serves WebAssembly functions A NATS subscriber and publisher (written with WebAssembly) A MQTT subscriber and publisher (written with WebAssembly) A CLI , you can simply execute a WASM function in a terminal Capsule is developed with GoLang and thanks to the \ud83d\udc9c Wazero project The wasm modules are developed in GoLang and compiled with TinyGo \ud83d\udc9c (with the WASI specification)","title":"What is Capsule?"},{"location":"#what-does-a-wasm-function-look-like-with-capsule","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . SetHandleHttp ( Handle ) } func Handle ( request hf . Request ) ( response hf . Response , errResp error ) { headersResp := map [ string ] string { \"Content-Type\" : \"application/json; charset=utf-8\" , } jsondoc := `{\"message\": \"\ud83d\udc4b Hello World \ud83c\udf0d\"}` return hf . Response { Body : jsondoc , Headers : headersResp }, err }","title":"What does a WASM function look like with Capsule?"},{"location":"#what-are-the-added-values-of-capsule","text":"","title":"What are the added values of Capsule?"},{"location":"#capsule-brings-superpowers-to-the-wasm-functions","text":"Thanks to host functions provided by Capsule , the WASM functions can: Description Host function Print a message to the console hf.Log(string) Read files hf.ReadFile(\"about.txt\") Write files hf.WriteFile(\"hello.txt\", \"\ud83d\udc4b HELLO WORLD \ud83c\udf0d\") Read value of the environment variables hf.GetEnv(\"MESSAGE\") Make HTTP requests hf.Http(\"https://httpbin.org/post\", \"POST\", headers, \"\ud83d\udc4b hello world \ud83c\udf0d\") Use memory cache (set) hf.MemorySet(\"message\", \"\ud83d\ude80 hello is started\") hf.MemoryGet(\"message\") Make Redis queries hf.RedisSet(\"greetings\", \"Hello World\") hf.RedisGet(\"greetings\") hf.RedisKeys(\"bob*\") Make CouchBase N1QL Query jsonStringArray, err := hf.CouchBaseQuery(query) Use Nats hf.NatsPublish(\"subject\", \"hello\") hf.NatsReply(\"it's a wasm module here\", 10) hf.NatsGetSubject() hf.NatsGetServer() hf.NatsConnectPublish(\"nats.devsecops.fun:4222\", \"subject\", \"\ud83d\udd90 Hello from WASM with Nats \ud83d\udc9c\") hf.NatsConnectRequest(\"nats.devsecops.fun:4222\", \"subject\", \"\ud83d\udc4b Hello World \ud83c\udf0d\", 1) Use MQTT hf.MqttConnectPublish(\"127.0.0.1:1883\", \"sensor_id0\", \"topic\", \"\ud83d\udc4b Hello World \ud83c\udf0d\") hf.MqttGetTopic() hf.MqttPublish(\"topic\", \"it's a wasm module here\") Manage Errors \ud83d\udd90 \ud83d\udea7 it's a work in progress hf.GetExitError() hf.GetExitCode()","title":"Capsule brings superpowers to the WASM functions"},{"location":"#information","text":"Label Description Issues https://github.com/bots-garden/capsule/issues Last release v0.2.8 \ud83e\udda4 [dodo] Dev release v0.2.9 \ud83e\udd9c [parrot] \ud83d\udea7 in progress Releases https://github.com/bots-garden/capsule/releases","title":"Information"},{"location":"#whats-new","text":"v0.2.8 : Capsule uses now Fiber instead Gin . The size of the Capsule Runner Docker image is now 16.8M!","title":"What's new"},{"location":"capsule-faas/","text":"Capsule FaaS (experimental) There are four additional components to use Capsule (the wasm module launcher/executor) in FaaS mode: capsule-registry : a wasm module registry (\ud83d\udea7 support of https://wapm.io/ in progress) capsule-reverse-proxy : a reverse-proxy to simplify the functions (wasm modules) access capsule-worker : a server to start the functions (wasm modules) remotely capsule-ctl (short name: caps ): a CLI to facilitate the interaction with the worker You can use the capsule registry independently of FaaS mode, only to provide wasm modules to the capsule launcher You can use the capsule reverse-proxy independently of FaaS mode, only to get only one access URL","title":"Capsule FaaS"},{"location":"capsule-faas/#capsule-faas-experimental","text":"There are four additional components to use Capsule (the wasm module launcher/executor) in FaaS mode: capsule-registry : a wasm module registry (\ud83d\udea7 support of https://wapm.io/ in progress) capsule-reverse-proxy : a reverse-proxy to simplify the functions (wasm modules) access capsule-worker : a server to start the functions (wasm modules) remotely capsule-ctl (short name: caps ): a CLI to facilitate the interaction with the worker You can use the capsule registry independently of FaaS mode, only to provide wasm modules to the capsule launcher You can use the capsule reverse-proxy independently of FaaS mode, only to get only one access URL","title":"Capsule FaaS (experimental)"},{"location":"cookbook/","text":"\ud83e\udd58 CookBook \ud83d\udea7 this is a work in progress Next recipe: deploy a Capsule function on Civo","title":"CookBook"},{"location":"cookbook/#cookbook","text":"\ud83d\udea7 this is a work in progress Next recipe: deploy a Capsule function on Civo","title":"\ud83e\udd58 CookBook"},{"location":"dev-guide/","text":"Developer Guide First CLI function Create a go.mod file: ( go mod init cli-say-hello ) 1 2 3 module cli-say-hello go 1.18 Install the Capsule dependencies: 1 go get github.com/bots-garden/capsule/capsulemodule/hostfunctions Create a hello.go file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main () { hf . SetHandle ( Handle ) } func Handle ( params [] string ) ( string , error ) { var err error for _ , param := range params { hf . Log ( \"- parameter is: \" + param ) } ret := \"The first parameter is: \" + params [ 0 ] return ret , err // err = nil } hf.SetHandle(Handle) defines the called wasm function hf.Log(string) prints a value Build the wasm module: 1 tinygo build -o hello.wasm -scheduler = none --no-debug -target wasi ./hello.go Execute the Handle function: 1 2 3 4 ./capsule \\ -wasm = ./hello.wasm \\ -mode = cli \\ \"\ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83\" 1234 \"Bob Morane\" -wasm flag: the path to the wasm file -mode execution mode output: 1 2 3 4 - parameter is: \ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83 - parameter is: 1234 - parameter is: Bob Morane The first parameter is: \ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83 First HTTP function Create a go.mod file: ( go mod init http-say-hello ) 1 2 3 module http-say-hello go 1.18 To serve the function through http, you need to change the signature of the Handle function: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main () { hf . SetHandleHttp ( Handle ) } func Handle ( request hf . Request ) ( response hf . Response , errResp error ) { hf . Log ( \"\ud83d\udcdd Body: \" + request . Body ) // Read the request headers hf . Log ( \"Content-Type: \" + request . Headers [ \"Content-Type\" ]) hf . Log ( \"Content-Length: \" + request . Headers [ \"Content-Length\" ]) hf . Log ( \"User-Agent: \" + request . Headers [ \"User-Agent\" ]) // Read the MESSAGE environment variable envMessage , err := hf . GetEnv ( \"MESSAGE\" ) if err != nil { hf . Log ( \"\ud83d\ude21 \" + err . Error ()) } else { hf . Log ( \"Environment variable: \" + envMessage ) } // Set the response content type and add a message header headersResp := map [ string ] string { \"Content-Type\" : \"application/json; charset=utf-8\" , \"Message\" : \"\ud83d\udc4b hello world \ud83c\udf0d\" , } jsonResponse := `{\"message\": \"hey people!\"}` return hf . Response { Body : jsonResponse , Headers : headersResp }, err } hf.SetHandleHttp(Handle) defines the called wasm function hf.Log(string) prints a value hf.GetEnv(\"MESSAGE\") get the value of the MESSAGE environment variable Build the wasm module: 1 tinygo build -o hello.wasm -scheduler = none --no-debug -target wasi ./hello.go Serve the Handle function: 1 2 3 4 5 export MESSAGE = \"\ud83d\udd90 good morning \ud83d\ude04\" ./capsule \\ -wasm = ./hello.wasm \\ -mode = http \\ -httpPort = 8080 Call the Handle function: 1 2 3 4 curl -v -X POST \\ http://localhost:8080 \\ -H 'content-type: application/json; charset=utf-8' \\ -d '{\"message\": \"TinyGo \ud83d\udc9a wasm\"}' request output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 > POST / HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.79.1 > Accept: */* > content-type: application/json ; charset = utf-8 > Content-Length: 31 > * Mark bundle as not supporting multiuse < HTTP/1.1 200 OK < Content-Type: application/json ; charset = utf-8 < Message: \ud83d\udc4b hello world \ud83c\udf0d < Date: Sat, 30 Jul 2022 19 :17:28 GMT < Content-Length: 26 < { \"message\" : \"hey people!\" } log server output: 1 2 3 4 5 \ud83d\udcdd body: { \"message\" : \"TinyGo \ud83d\udc9a wasm\" } Content-Type: application/json ; charset = utf-8 Content-Length: 31 User-Agent: curl/7.79.1 Environment variable: \ud83d\udd90 good morning \ud83d\ude04 OnLoad function If you add an OnLoad exported function to the module, it will be executed at the start of the HTTP launcher (capsule). the main function will be executed too 1 2 3 4 //export OnLoad func OnLoad () { hf . Log ( \"\ud83d\udc4b from the OnLoad function\" ) } It can be useful to register your wasm service to a backend (Redis, CouchBase, ...) OnExit function If you add an OnExit exported function to the module, it will be executed when you stop the HTTP launcher (capsule). the main function will be executed too 1 2 3 4 //export OnExit func OnExit () { hf . Log ( \"\ud83d\udc4b from the OnExit function\" ) } It can be useful to unregister your wasm service from a backend (Redis, CouchBase, ...) GetExitError and GetExitCode function \ud83d\udd90\ud83d\udea7 it's a work in progress (it's not implemented entirely) 1 2 3 4 5 6 //export OnExit func OnExit () { hf . Log ( \"\ud83d\udc4b\ud83e\udd17 have a nice day\" ) hf . Log ( \"Exit Error: \" + hf . GetExitError ()) hf . Log ( \"Exit Code: \" + hf . GetExitCode ()) } Remote loading of the wasm module You can download the wasm module from a remote location before executing it: For example, provide the wasm file with an HTTP server, run this command at the root of your project: 1 python3 -m http.server 9090 Now you can download the wasm file with this url: http://localhost:9090/hello.wasm Serve the Handle function: 1 2 3 4 5 6 export MESSAGE = \"\ud83d\udd90 good morning \ud83d\ude04\" ./capsule \\ -url = http://localhost:9090/hello.wasm \\ -wasm = ./tmp/hello.wasm \\ -mode = http \\ -httpPort = 8080 -url flag: the download url -wasm flag: the path where to save the wasm file GET Request Capsule accept the GET requests, so you can serve, for example, HTML: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main () { hf . SetHandleHttp ( Handle ) } func Handle ( request hf . Request ) ( response hf . Response , errResp error ) { html := ` <html> <head> <title>Wasm is fantastic \ud83d\ude0d</title> </head> <body> <h1>\ud83d\udc4b Hello World \ud83c\udf0d</h1> <h2>Served with \ud83d\udc9c with Capsule \ud83d\udc8a</h2> </body> </html> ` headersResp := map [ string ] string { \"Content-Type\" : \"text/html; charset=utf-8\" , } return hf . Response { Body : html , Headers : headersResp }, nil } Build the wasm module: 1 tinygo build -o hello.wasm -scheduler = none --no-debug -target wasi ./hello.go Serve the Handle \"function page\": 1 2 3 4 ./capsule \\ -wasm = ./hello.wasm \\ -mode = http \\ -httpPort = 8080 Now, you can open http://localhost:8080 with your browser or run a curl request: 1 curl http://localhost:8080 First Nats function \ud83d\udd90\ud83d\udea7 The NAT integration with Capsule is a work in progress and the functions are subject to change NATS is an open-source messaging system. About NATS: https://nats.io/ and https://docs.nats.io/ Nats Overview: https://docs.nats.io/nats-concepts/overview Requirements NATS Server You need to install and run a NATS server: https://docs.nats.io/running-a-nats-service/introduction/installation. Otherwise, I created a Virtual Machine for this; If you have installed Multipass , go to the ./nats/vm-nats directory of this project. I created some scripts for my experiments: create-vm.sh create the multipass VM, the settings of the VM are stored in the vm.nats.config 01-install-nats-server.sh install the NATS server inside the VM 02-start-nats-server.sh start the NATS server 03-stop-nats-server.sh stop the NATS server stop-vm.sh stop the VM start-vm.sh start the VM destroy-vm.sh delete the VM shell-vm.sh SSH connect to the VM NATS Client You need a NATS client to publish messages. You can find sample of Go and Node.js NATS clients in the ./nats/clients . Run Capsule as a NATS subscriber: 1 2 3 4 5 capsule \\ -wasm = ../wasm_modules/capsule-nats-subscriber/hello.wasm \\ -mode = nats \\ -natssrv = nats.devsecops.fun:4222 \\ -subject = ping use the \"NATS mode\": -mode=nats define the NATS subject: -subject=<subject_name> define the address of the NATS server: -natssrv=<nats_server:port> NATS function A Capsule NATS function is a subscription to a subject. Capsule is listening on a subject(like a MQTT topic) and execute a function every time a message is posted on the subject: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . OnNatsMessage ( Handle ) // define the triggered function when a message \"arrives\" on the subject/topic } // at every message on the subject channel, the `Handle` function is executed func Handle ( params [] string ) { // send a message to another subject _ , err := hf . NatsPublish ( \"notify\" , \"it's a wasm module here\" ) if err != nil { hf . Log ( \"\ud83d\ude21 ouch something bad is happening\" ) hf . Log ( err . Error ()) } } Capsule NATS publisher Publish NATS messages from capsule You can use a WASM Capsule module to publish NATS messages, even if Capsule is not started in \"nats\" mode, for example from a WASM CLI Capsule module : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main () { hf . SetHandle ( Handle ) } func Handle ( params [] string ) ( string , error ) { var errs [] string // a new connection is created at every call/publish _ , err1stMsg := hf . NatsConnectPublish ( \"nats.devsecops.fun:4222\" , \"ping\" , \"\ud83d\udd90 Hello from WASM with Nats \ud83d\udc9c\" ) _ , err2ndMsg := hf . NatsConnectPublish ( \"nats.devsecops.fun:4222\" , \"notify\" , \"\ud83d\udc4b Hello World \ud83c\udf0d\" ) if err1stMsg != nil { errs = append ( errs , err1stMsg . Error ()) } if err2ndMsg != nil { errs = append ( errs , err2ndMsg . Error ()) } return \"NATS Rocks!\" , errors . New ( strings . Join ( errs , \"|\" )) } In this use case, you need to define the NATS server and create a connection Request and Reply A NATS \"publisher\" can make a request to a NATS \"subscriber\" and wait for an answer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main () { hf . SetHandle ( Handle ) } func Handle ( params [] string ) ( string , error ) { // Publish and wait for an answer; 1 is the timeout in seconds res , err := hf . NatsConnectRequest ( \"nats.devsecops.fun:4222\" , \"notify\" , \"\ud83d\udc4b Hello World \ud83c\udf0d\" , 1 ) if err != nil { hf . Log ( \"\ud83d\udd34\" + err . Error ()) } else { // Display the answer hf . Log ( \"\ud83d\udd35\" + res ) } return \"NATS Rocks!\" , err } A NATS \"subscriber\" can reply to a request received on its subject 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . OnNatsMessage ( Handle ) } func Handle ( params [] string ) { hf . Log ( \"Message on subject: \" + hf . NatsGetSubject () + \", \ud83c\udf89 message: \" + params [ 0 ]) // reply to the message on the current subject; 10 is the timeout in seconds _ , _ = hf . NatsReply ( \"Hey! What's up\" , 10 ) } First MQTT function \ud83d\udd90\ud83d\udea7 The MQTT integration with Capsule is a work in progress and the functions are subject to change MQTT is a standard for IOT message. About MQTT: https://mqtt.org/ Requirements MQTT Server You need to install and run a MQTT server. To do so, go to the ./mqtt directory of this project and run the docker-compose file Run Capsule as a MQTT subscriber: 1 2 3 4 5 6 capsule \\ -wasm = ../wasm_modules/capsule-mqtt-subscriber/hello.wasm \\ -mode = mqtt \\ -mqttsrv = 127 .0.0.1:1883 \\ -topic = topic/sensor0 \\ -clientId = sensor use the \"MQTT mode\": -mode=mqtt define the MQTT topic: -topic=<topic_name> define the MQTT clientId: -clientId=<clientId> define the address of the MQTT server: -mqttsrv=<mqtt_server:port> MQTT function A Capsule MQTT function is a subscription to a subject. Capsule is listening on a topic and execute a function every time a message is posted on the subject: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . OnMqttMessage ( Handle ) // define the triggered function when a message \"arrives\" on the topic } // at every message on the subject channel, the `Handle` function is executed func Handle ( params [] string ) { // send a message to another subject _ , err := hf . MqttPublish ( \"topic/reply\" , \"it's a wasm module here\" ) if err != nil { hf . Log ( \"\ud83d\ude21 ouch something bad is happening\" ) hf . Log ( err . Error ()) } } Capsule MQTT publisher Publish MQTT messages from capsule You can use a WASM Capsule module to MQTT messages, even if Capsule is not started in \"mqtt\" mode, for example from a WASM CLI Capsule module : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main () { hf . SetHandle ( Handle ) } func Handle ( params [] string ) ( string , error ) { var errs [] string // a new connection is created at every call/publish _ , err1stMsg := hf . MqttConnectPublish ( \"127.0.0.1:1883\" , \"sensor\" , \"topic/sensor1\" , \"\ud83d\udd90 Hello from WASM with MQTT \ud83d\udc9c\" ) _ , err2ndMsg := hf . MqttConnectPublish ( \"127.0.0.1:1883\" , \"sensor\" , \"topic/sensor2\" , \"\ud83d\udc4b Hello World \ud83c\udf0d\" ) if err1stMsg != nil { errs = append ( errs , err1stMsg . Error ()) } if err2ndMsg != nil { errs = append ( errs , err2ndMsg . Error ()) } return \"MQTT Rocks!\" , errors . New ( strings . Join ( errs , \"|\" )) } In this use case, you need to define the MQTT server and create a connection","title":"Developer guide"},{"location":"dev-guide/#developer-guide","text":"","title":"Developer Guide"},{"location":"dev-guide/#first-cli-function","text":"Create a go.mod file: ( go mod init cli-say-hello ) 1 2 3 module cli-say-hello go 1.18 Install the Capsule dependencies: 1 go get github.com/bots-garden/capsule/capsulemodule/hostfunctions Create a hello.go file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main () { hf . SetHandle ( Handle ) } func Handle ( params [] string ) ( string , error ) { var err error for _ , param := range params { hf . Log ( \"- parameter is: \" + param ) } ret := \"The first parameter is: \" + params [ 0 ] return ret , err // err = nil } hf.SetHandle(Handle) defines the called wasm function hf.Log(string) prints a value Build the wasm module: 1 tinygo build -o hello.wasm -scheduler = none --no-debug -target wasi ./hello.go Execute the Handle function: 1 2 3 4 ./capsule \\ -wasm = ./hello.wasm \\ -mode = cli \\ \"\ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83\" 1234 \"Bob Morane\" -wasm flag: the path to the wasm file -mode execution mode output: 1 2 3 4 - parameter is: \ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83 - parameter is: 1234 - parameter is: Bob Morane The first parameter is: \ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83","title":"First CLI function"},{"location":"dev-guide/#first-http-function","text":"Create a go.mod file: ( go mod init http-say-hello ) 1 2 3 module http-say-hello go 1.18 To serve the function through http, you need to change the signature of the Handle function: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main () { hf . SetHandleHttp ( Handle ) } func Handle ( request hf . Request ) ( response hf . Response , errResp error ) { hf . Log ( \"\ud83d\udcdd Body: \" + request . Body ) // Read the request headers hf . Log ( \"Content-Type: \" + request . Headers [ \"Content-Type\" ]) hf . Log ( \"Content-Length: \" + request . Headers [ \"Content-Length\" ]) hf . Log ( \"User-Agent: \" + request . Headers [ \"User-Agent\" ]) // Read the MESSAGE environment variable envMessage , err := hf . GetEnv ( \"MESSAGE\" ) if err != nil { hf . Log ( \"\ud83d\ude21 \" + err . Error ()) } else { hf . Log ( \"Environment variable: \" + envMessage ) } // Set the response content type and add a message header headersResp := map [ string ] string { \"Content-Type\" : \"application/json; charset=utf-8\" , \"Message\" : \"\ud83d\udc4b hello world \ud83c\udf0d\" , } jsonResponse := `{\"message\": \"hey people!\"}` return hf . Response { Body : jsonResponse , Headers : headersResp }, err } hf.SetHandleHttp(Handle) defines the called wasm function hf.Log(string) prints a value hf.GetEnv(\"MESSAGE\") get the value of the MESSAGE environment variable Build the wasm module: 1 tinygo build -o hello.wasm -scheduler = none --no-debug -target wasi ./hello.go Serve the Handle function: 1 2 3 4 5 export MESSAGE = \"\ud83d\udd90 good morning \ud83d\ude04\" ./capsule \\ -wasm = ./hello.wasm \\ -mode = http \\ -httpPort = 8080 Call the Handle function: 1 2 3 4 curl -v -X POST \\ http://localhost:8080 \\ -H 'content-type: application/json; charset=utf-8' \\ -d '{\"message\": \"TinyGo \ud83d\udc9a wasm\"}' request output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 > POST / HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.79.1 > Accept: */* > content-type: application/json ; charset = utf-8 > Content-Length: 31 > * Mark bundle as not supporting multiuse < HTTP/1.1 200 OK < Content-Type: application/json ; charset = utf-8 < Message: \ud83d\udc4b hello world \ud83c\udf0d < Date: Sat, 30 Jul 2022 19 :17:28 GMT < Content-Length: 26 < { \"message\" : \"hey people!\" } log server output: 1 2 3 4 5 \ud83d\udcdd body: { \"message\" : \"TinyGo \ud83d\udc9a wasm\" } Content-Type: application/json ; charset = utf-8 Content-Length: 31 User-Agent: curl/7.79.1 Environment variable: \ud83d\udd90 good morning \ud83d\ude04","title":"First HTTP function"},{"location":"dev-guide/#onload-function","text":"If you add an OnLoad exported function to the module, it will be executed at the start of the HTTP launcher (capsule). the main function will be executed too 1 2 3 4 //export OnLoad func OnLoad () { hf . Log ( \"\ud83d\udc4b from the OnLoad function\" ) } It can be useful to register your wasm service to a backend (Redis, CouchBase, ...)","title":"OnLoad function"},{"location":"dev-guide/#onexit-function","text":"If you add an OnExit exported function to the module, it will be executed when you stop the HTTP launcher (capsule). the main function will be executed too 1 2 3 4 //export OnExit func OnExit () { hf . Log ( \"\ud83d\udc4b from the OnExit function\" ) } It can be useful to unregister your wasm service from a backend (Redis, CouchBase, ...)","title":"OnExit function"},{"location":"dev-guide/#getexiterror-and-getexitcode-function","text":"\ud83d\udd90\ud83d\udea7 it's a work in progress (it's not implemented entirely) 1 2 3 4 5 6 //export OnExit func OnExit () { hf . Log ( \"\ud83d\udc4b\ud83e\udd17 have a nice day\" ) hf . Log ( \"Exit Error: \" + hf . GetExitError ()) hf . Log ( \"Exit Code: \" + hf . GetExitCode ()) }","title":"GetExitError and GetExitCode function"},{"location":"dev-guide/#remote-loading-of-the-wasm-module","text":"You can download the wasm module from a remote location before executing it: For example, provide the wasm file with an HTTP server, run this command at the root of your project: 1 python3 -m http.server 9090 Now you can download the wasm file with this url: http://localhost:9090/hello.wasm Serve the Handle function: 1 2 3 4 5 6 export MESSAGE = \"\ud83d\udd90 good morning \ud83d\ude04\" ./capsule \\ -url = http://localhost:9090/hello.wasm \\ -wasm = ./tmp/hello.wasm \\ -mode = http \\ -httpPort = 8080 -url flag: the download url -wasm flag: the path where to save the wasm file","title":"Remote loading of the wasm module"},{"location":"dev-guide/#get-request","text":"Capsule accept the GET requests, so you can serve, for example, HTML: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main () { hf . SetHandleHttp ( Handle ) } func Handle ( request hf . Request ) ( response hf . Response , errResp error ) { html := ` <html> <head> <title>Wasm is fantastic \ud83d\ude0d</title> </head> <body> <h1>\ud83d\udc4b Hello World \ud83c\udf0d</h1> <h2>Served with \ud83d\udc9c with Capsule \ud83d\udc8a</h2> </body> </html> ` headersResp := map [ string ] string { \"Content-Type\" : \"text/html; charset=utf-8\" , } return hf . Response { Body : html , Headers : headersResp }, nil } Build the wasm module: 1 tinygo build -o hello.wasm -scheduler = none --no-debug -target wasi ./hello.go Serve the Handle \"function page\": 1 2 3 4 ./capsule \\ -wasm = ./hello.wasm \\ -mode = http \\ -httpPort = 8080 Now, you can open http://localhost:8080 with your browser or run a curl request: 1 curl http://localhost:8080","title":"GET Request"},{"location":"dev-guide/#first-nats-function","text":"\ud83d\udd90\ud83d\udea7 The NAT integration with Capsule is a work in progress and the functions are subject to change NATS is an open-source messaging system. About NATS: https://nats.io/ and https://docs.nats.io/ Nats Overview: https://docs.nats.io/nats-concepts/overview","title":"First Nats function"},{"location":"dev-guide/#requirements","text":"","title":"Requirements"},{"location":"dev-guide/#nats-server","text":"You need to install and run a NATS server: https://docs.nats.io/running-a-nats-service/introduction/installation. Otherwise, I created a Virtual Machine for this; If you have installed Multipass , go to the ./nats/vm-nats directory of this project. I created some scripts for my experiments: create-vm.sh create the multipass VM, the settings of the VM are stored in the vm.nats.config 01-install-nats-server.sh install the NATS server inside the VM 02-start-nats-server.sh start the NATS server 03-stop-nats-server.sh stop the NATS server stop-vm.sh stop the VM start-vm.sh start the VM destroy-vm.sh delete the VM shell-vm.sh SSH connect to the VM","title":"NATS Server"},{"location":"dev-guide/#nats-client","text":"You need a NATS client to publish messages. You can find sample of Go and Node.js NATS clients in the ./nats/clients .","title":"NATS Client"},{"location":"dev-guide/#run-capsule-as-a-nats-subscriber","text":"1 2 3 4 5 capsule \\ -wasm = ../wasm_modules/capsule-nats-subscriber/hello.wasm \\ -mode = nats \\ -natssrv = nats.devsecops.fun:4222 \\ -subject = ping use the \"NATS mode\": -mode=nats define the NATS subject: -subject=<subject_name> define the address of the NATS server: -natssrv=<nats_server:port>","title":"Run Capsule as a NATS subscriber:"},{"location":"dev-guide/#nats-function","text":"A Capsule NATS function is a subscription to a subject. Capsule is listening on a subject(like a MQTT topic) and execute a function every time a message is posted on the subject: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . OnNatsMessage ( Handle ) // define the triggered function when a message \"arrives\" on the subject/topic } // at every message on the subject channel, the `Handle` function is executed func Handle ( params [] string ) { // send a message to another subject _ , err := hf . NatsPublish ( \"notify\" , \"it's a wasm module here\" ) if err != nil { hf . Log ( \"\ud83d\ude21 ouch something bad is happening\" ) hf . Log ( err . Error ()) } }","title":"NATS function"},{"location":"dev-guide/#capsule-nats-publisher","text":"Publish NATS messages from capsule You can use a WASM Capsule module to publish NATS messages, even if Capsule is not started in \"nats\" mode, for example from a WASM CLI Capsule module : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main () { hf . SetHandle ( Handle ) } func Handle ( params [] string ) ( string , error ) { var errs [] string // a new connection is created at every call/publish _ , err1stMsg := hf . NatsConnectPublish ( \"nats.devsecops.fun:4222\" , \"ping\" , \"\ud83d\udd90 Hello from WASM with Nats \ud83d\udc9c\" ) _ , err2ndMsg := hf . NatsConnectPublish ( \"nats.devsecops.fun:4222\" , \"notify\" , \"\ud83d\udc4b Hello World \ud83c\udf0d\" ) if err1stMsg != nil { errs = append ( errs , err1stMsg . Error ()) } if err2ndMsg != nil { errs = append ( errs , err2ndMsg . Error ()) } return \"NATS Rocks!\" , errors . New ( strings . Join ( errs , \"|\" )) } In this use case, you need to define the NATS server and create a connection","title":"Capsule NATS publisher"},{"location":"dev-guide/#request-and-reply","text":"A NATS \"publisher\" can make a request to a NATS \"subscriber\" and wait for an answer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main () { hf . SetHandle ( Handle ) } func Handle ( params [] string ) ( string , error ) { // Publish and wait for an answer; 1 is the timeout in seconds res , err := hf . NatsConnectRequest ( \"nats.devsecops.fun:4222\" , \"notify\" , \"\ud83d\udc4b Hello World \ud83c\udf0d\" , 1 ) if err != nil { hf . Log ( \"\ud83d\udd34\" + err . Error ()) } else { // Display the answer hf . Log ( \"\ud83d\udd35\" + res ) } return \"NATS Rocks!\" , err } A NATS \"subscriber\" can reply to a request received on its subject 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . OnNatsMessage ( Handle ) } func Handle ( params [] string ) { hf . Log ( \"Message on subject: \" + hf . NatsGetSubject () + \", \ud83c\udf89 message: \" + params [ 0 ]) // reply to the message on the current subject; 10 is the timeout in seconds _ , _ = hf . NatsReply ( \"Hey! What's up\" , 10 ) }","title":"Request and Reply"},{"location":"dev-guide/#first-mqtt-function","text":"\ud83d\udd90\ud83d\udea7 The MQTT integration with Capsule is a work in progress and the functions are subject to change MQTT is a standard for IOT message. About MQTT: https://mqtt.org/","title":"First MQTT function"},{"location":"dev-guide/#requirements_1","text":"","title":"Requirements"},{"location":"dev-guide/#mqtt-server","text":"You need to install and run a MQTT server. To do so, go to the ./mqtt directory of this project and run the docker-compose file","title":"MQTT Server"},{"location":"dev-guide/#run-capsule-as-a-mqtt-subscriber","text":"1 2 3 4 5 6 capsule \\ -wasm = ../wasm_modules/capsule-mqtt-subscriber/hello.wasm \\ -mode = mqtt \\ -mqttsrv = 127 .0.0.1:1883 \\ -topic = topic/sensor0 \\ -clientId = sensor use the \"MQTT mode\": -mode=mqtt define the MQTT topic: -topic=<topic_name> define the MQTT clientId: -clientId=<clientId> define the address of the MQTT server: -mqttsrv=<mqtt_server:port>","title":"Run Capsule as a MQTT subscriber:"},{"location":"dev-guide/#mqtt-function","text":"A Capsule MQTT function is a subscription to a subject. Capsule is listening on a topic and execute a function every time a message is posted on the subject: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . OnMqttMessage ( Handle ) // define the triggered function when a message \"arrives\" on the topic } // at every message on the subject channel, the `Handle` function is executed func Handle ( params [] string ) { // send a message to another subject _ , err := hf . MqttPublish ( \"topic/reply\" , \"it's a wasm module here\" ) if err != nil { hf . Log ( \"\ud83d\ude21 ouch something bad is happening\" ) hf . Log ( err . Error ()) } }","title":"MQTT function"},{"location":"dev-guide/#capsule-mqtt-publisher","text":"Publish MQTT messages from capsule You can use a WASM Capsule module to MQTT messages, even if Capsule is not started in \"mqtt\" mode, for example from a WASM CLI Capsule module : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main () { hf . SetHandle ( Handle ) } func Handle ( params [] string ) ( string , error ) { var errs [] string // a new connection is created at every call/publish _ , err1stMsg := hf . MqttConnectPublish ( \"127.0.0.1:1883\" , \"sensor\" , \"topic/sensor1\" , \"\ud83d\udd90 Hello from WASM with MQTT \ud83d\udc9c\" ) _ , err2ndMsg := hf . MqttConnectPublish ( \"127.0.0.1:1883\" , \"sensor\" , \"topic/sensor2\" , \"\ud83d\udc4b Hello World \ud83c\udf0d\" ) if err1stMsg != nil { errs = append ( errs , err1stMsg . Error ()) } if err2ndMsg != nil { errs = append ( errs , err2ndMsg . Error ()) } return \"MQTT Rocks!\" , errors . New ( strings . Join ( errs , \"|\" )) } In this use case, you need to define the MQTT server and create a connection","title":"Capsule MQTT publisher"},{"location":"getting-started/","text":"\ud83d\ude80 Getting Started The simplest way to create your first Capsule Function is to use Cabu , a kind of CLI helper (see the tooling section for more information). Install Cabu (Capsule Builder) 1 2 CAPSULE_BUILDER_VERSION = \"v0.0.2\" wget -O - https://raw.githubusercontent.com/bots-garden/capsule-function-builder/ ${ CAPSULE_BUILDER_VERSION } /install-capsule-builder.sh | bash Generate a new project function Cabu can generate function project from templates: 1 2 3 # template name: `service-get` # function project name `hello-world` cabu generate service-get hello-world At the first launch, Cabu will pull a docker image with all the necessary resources to build the WASM function. 1 2 3 4 5 6 7 8 9 \ud83d\udc33 using k33g/capsule-builder:0.0.2 Unable to find image 'k33g/capsule-builder:0.0.2' locally 0 .0.2: Pulling from k33g/capsule-builder 68c15fb212c3: Pull complete 28b965d0936e: Pull complete f7ba6ae51b0b: Pull complete Digest: sha256:47ebf274d7c378d1795f6c8a78d71c45e8368b33a7a3ba8e48ef131a08fd9ac4 Status: Downloaded newer image for k33g/capsule-builder:0.0.2 \u2705\ud83d\ude42 hello-world function generated Cabu has generated the hello-world project: 1 2 3 4 . \u251c\u2500\u2500 hello-world \u2502 \u251c\u2500\u2500 go.mod \u2502 \u2514\u2500\u2500 hello-world.go With the following source code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . SetHandleHttp ( Handle ) } func Handle ( req hf . Request ) ( resp hf . Response , errResp error ) { headers := map [ string ] string { \"Content-Type\" : \"text/html; charset=utf-8\" , } resp = hf . Response { Body : \"<h1>\ud83d\udc4b hello world \ud83c\udf0d</h1>\" , Headers : headers , } return resp , nil } Build the hello-world function For building the WASM function, use the cabu build command: 1 2 cd hello-world cabu build . hello-world.go hello-world.wasm Serve the hello-world function Before serving the function, you need to install Capsule : Install the Capsule runner Before executing or running a function, you need to install the last release of Capsule : The script will install Capsule in $HOME/.local/bin if you want to install Capsule somewhere else, override the CAPSULE_PATH variable (default value: CAPSULE_PATH=\"$HOME/.local/bin\" ) \ud83d\udd90 On Linux : 1 2 export CAPSULE_VERSION = \"v0.2.8\" wget -O - https://raw.githubusercontent.com/bots-garden/capsule/ ${ CAPSULE_VERSION } /install-capsule-launcher.sh | bash \ud83d\udd90 On macOS : create the $HOME/.local/bin directory add it to your path: 1 2 export CAPSULE_RUNNER_PATH = \" $HOME /.local\" export PATH = \" $CAPSULE_RUNNER_PATH /bin: $PATH \" Serve the function 1 2 3 4 capsule \\ -wasm = ./hello-world.wasm \\ -mode = http \\ -httpPort = 8080 Reach http://localhost:8080 with your browser Serve the function with the Capsule Docker image 1 2 3 4 5 6 7 docker run \\ -p 8080 :8080 \\ -v $( pwd ) :/app --rm k33g/capsule-launcher:0.2.8 \\ /capsule \\ -wasm = ./app/hello-world.wasm \\ -mode = http \\ -httpPort = 8080","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"The simplest way to create your first Capsule Function is to use Cabu , a kind of CLI helper (see the tooling section for more information).","title":"\ud83d\ude80 Getting Started"},{"location":"getting-started/#install-cabu-capsule-builder","text":"1 2 CAPSULE_BUILDER_VERSION = \"v0.0.2\" wget -O - https://raw.githubusercontent.com/bots-garden/capsule-function-builder/ ${ CAPSULE_BUILDER_VERSION } /install-capsule-builder.sh | bash","title":"Install Cabu (Capsule Builder)"},{"location":"getting-started/#generate-a-new-project-function","text":"Cabu can generate function project from templates: 1 2 3 # template name: `service-get` # function project name `hello-world` cabu generate service-get hello-world At the first launch, Cabu will pull a docker image with all the necessary resources to build the WASM function. 1 2 3 4 5 6 7 8 9 \ud83d\udc33 using k33g/capsule-builder:0.0.2 Unable to find image 'k33g/capsule-builder:0.0.2' locally 0 .0.2: Pulling from k33g/capsule-builder 68c15fb212c3: Pull complete 28b965d0936e: Pull complete f7ba6ae51b0b: Pull complete Digest: sha256:47ebf274d7c378d1795f6c8a78d71c45e8368b33a7a3ba8e48ef131a08fd9ac4 Status: Downloaded newer image for k33g/capsule-builder:0.0.2 \u2705\ud83d\ude42 hello-world function generated Cabu has generated the hello-world project: 1 2 3 4 . \u251c\u2500\u2500 hello-world \u2502 \u251c\u2500\u2500 go.mod \u2502 \u2514\u2500\u2500 hello-world.go With the following source code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . SetHandleHttp ( Handle ) } func Handle ( req hf . Request ) ( resp hf . Response , errResp error ) { headers := map [ string ] string { \"Content-Type\" : \"text/html; charset=utf-8\" , } resp = hf . Response { Body : \"<h1>\ud83d\udc4b hello world \ud83c\udf0d</h1>\" , Headers : headers , } return resp , nil }","title":"Generate a new project function"},{"location":"getting-started/#build-the-hello-world-function","text":"For building the WASM function, use the cabu build command: 1 2 cd hello-world cabu build . hello-world.go hello-world.wasm","title":"Build the hello-world function"},{"location":"getting-started/#serve-the-hello-world-function","text":"Before serving the function, you need to install Capsule :","title":"Serve the hello-world function"},{"location":"getting-started/#install-the-capsule-runner","text":"Before executing or running a function, you need to install the last release of Capsule : The script will install Capsule in $HOME/.local/bin if you want to install Capsule somewhere else, override the CAPSULE_PATH variable (default value: CAPSULE_PATH=\"$HOME/.local/bin\" ) \ud83d\udd90 On Linux : 1 2 export CAPSULE_VERSION = \"v0.2.8\" wget -O - https://raw.githubusercontent.com/bots-garden/capsule/ ${ CAPSULE_VERSION } /install-capsule-launcher.sh | bash \ud83d\udd90 On macOS : create the $HOME/.local/bin directory add it to your path: 1 2 export CAPSULE_RUNNER_PATH = \" $HOME /.local\" export PATH = \" $CAPSULE_RUNNER_PATH /bin: $PATH \"","title":"Install the Capsule runner"},{"location":"getting-started/#serve-the-function","text":"1 2 3 4 capsule \\ -wasm = ./hello-world.wasm \\ -mode = http \\ -httpPort = 8080 Reach http://localhost:8080 with your browser","title":"Serve the function"},{"location":"getting-started/#serve-the-function-with-the-capsule-docker-image","text":"1 2 3 4 5 6 7 docker run \\ -p 8080 :8080 \\ -v $( pwd ) :/app --rm k33g/capsule-launcher:0.2.8 \\ /capsule \\ -wasm = ./app/hello-world.wasm \\ -mode = http \\ -httpPort = 8080","title":"Serve the function with the Capsule Docker image"},{"location":"host-functions/","text":"Host functions \ud83d\udea7 this is a work in progress, each host function will be detailed with samples in the coming weeks. Capsule offers some capabilities to the wasm modules by providing some \"host functions\": Print a message 1 hf . Log ( \"\ud83d\udc4b Hello World \ud83c\udf0d\" ) Read and Write files 1 2 3 4 5 6 7 8 9 10 11 txt , err := hf . ReadFile ( \"about.txt\" ) if err != nil { hf . Log ( err . Error ()) } hf . Log ( txt ) newFile , err := hf . WriteFile ( \"hello.txt\" , \"\ud83d\udc4b HELLO WORLD \ud83c\udf0d\" ) if err != nil { hf . Log ( err . Error ()) } hf . Log ( newFile ) Read value of the environment variables 1 2 3 4 5 6 message , err := hf . GetEnv ( \"MESSAGE\" ) if err != nil { hf . Log ( err . Error ()) } else { hf . Log ( \"MESSAGE=\" + message ) } Make HTTP requests GET 1 2 3 4 5 6 ret , err := hf . Http ( \"https://httpbin.org/get\" , \"GET\" , headers , \"\" ) if err != nil { hf . Log ( \"\ud83d\ude21 error:\" + err . Error ()) } else { hf . Log ( \"\ud83d\udcddresult: \" + ret ) } POST 1 2 3 4 5 6 7 8 headers := map [ string ] string { \"Accept\" : \"application/json\" , \"Content-Type\" : \"text/html; charset=UTF-8\" } ret , err := hf . Http ( \"https://httpbin.org/post\" , \"POST\" , headers , \"\ud83d\udc4b hello world \ud83c\udf0d\" ) if err != nil { hf . Log ( \"\ud83d\ude21 error:\" + err . Error ()) } else { hf . Log ( \"\ud83d\udcddresult: \" + ret ) } Use memory cache MemorySet 1 _ , err := hf . MemorySet ( \"message\" , \"\ud83d\ude80 hello is started\" ) MemoryGet 1 value , err := hf . MemoryGet ( \"message\" ) MemoryKeys 1 2 3 4 5 6 7 8 9 keys , err := hf . MemoryKeys () // it will return an array of strings if err != nil { hf . Log ( err . Error ()) } for key , value := range keys { hf . Log ( key + \":\" + value ) } Make Redis queries \ud83d\udea7 this is a work in progress You need to run Capsule with these two environment variables: 1 2 REDIS_ADDR = \"localhost:6379\" REDIS_PWD = \"\" SET 1 2 3 4 5 6 7 // add a key, value res , err := hf . RedisSet ( \"greetings\" , \"Hello World\" ) if err != nil { hf . Log ( err . Error ()) } else { hf . Log ( \"Value: \" + res ) } GET 1 2 3 4 5 6 7 // read the value res , err := hf . RedisGet ( \"greetings\" ) if err != nil { hf . Log ( err . Error ()) } else { hf . Log ( \"Value: \" + res ) } KEYS 1 2 3 4 5 6 7 8 legion , err := hf . RedisKeys ( \"bob*\" ) if err != nil { hf . Log ( err . Error ()) } for _ , bob := range legion { hf . Log ( bob ) } Make CouchBase N1QL Query You need to run Capsule with these four environment variables: 1 2 3 4 COUCHBASE_CLUSTER = \"couchbase://localhost\" COUCHBASE_USER = \"admin\" COUCHBASE_PWD = \"ilovepandas\" COUCHBASE_BUCKET = \"wasm-data\" 1 2 3 4 bucketName , _ := hf . GetEnv ( \"COUCHBASE_BUCKET\" ) query := \"SELECT * FROM `\" + bucketName + \"`.data.docs\" jsonStringArray , err := hf . CouchBaseQuery ( query ) Nats NatsPublish(subject string, message string) : publish a message on a subject 1 _ , err := hf . NatsPublish ( \"notify\" , \"it's a wasm module here\" ) You must use the \"nats\" mode of Capsule as the NATS connection is defined at the start of Capsule and shared with the WASM module: 1 2 3 4 5 capsule \\ -wasm = ../wasm_modules/capsule-nats-subscriber/hello.wasm \\ -mode = nats \\ -natssrv = nats.devsecops.fun:4222 \\ -subject = ping NatsReply(message string, timeout uint32) : publish a message on the current subject and wait for an answer 1 _ , err := hf . NatsReply ( \"it's a wasm module here\" , 10 ) You must use the \"nats\" mode of Capsule as the NATS connection and the subscription are defined at the start of Capsule and shared with the WASM module. NatsGetSubject() : get the subject listened by the Capsule launcher 1 hf . Log ( \"\ud83d\udc42Listening on: \" + hf . NatsGetSubject ()) NatsGetServer() : get the connected NATS server 1 hf . Log ( \"\ud83d\udc4b NATS server: \" + hf . NatsGetServer ()) NatsConnectPublish(server string, subject string, message string) : connect to a NATS server and send a message on a subject 1 _ , err := hf . NatsConnectPublish ( \"nats.devsecops.fun:4222\" , \"ping\" , \"\ud83d\udd90 Hello from WASM with Nats \ud83d\udc9c\" ) You can use this function with all the running modes of Capsule NatsConnectPublish(server string, subject string, message string, timeout uint32) : connect to a NATS server and send a message on a subject 1 answer , err := hf . NatsConnectRequest ( \"nats.devsecops.fun:4222\" , \"notify\" , \"\ud83d\udc4b Hello World \ud83c\udf0d\" , 1 ) You can use this function with all the running modes of Capsule MQTT You must use the \"mqtt\" mode of Capsule as the MQTT connection is defined at the start of Capsule and shared with the WASM module: 1 2 3 4 5 6 capsule \\ -wasm = ../wasm_modules/capsule-mqtt-subscriber/hello.wasm \\ -mode = mqtt \\ -mqttsrv = 127 .0.0.1:1883 \\ -topic = topic/sensor0 \\ -clientId = sensor_id1 MQTT Handler as a Subscriber \ud83d\udd90 you have to call hf.OnMqttMessage(Handle) from the main function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) // the topic is defined when launching the capsule launcher func main () { hf . OnMqttMessage ( Handle ) } func Handle ( params [] string ) { message := params [ 0 ] hf . Log ( \"\ud83d\udc4b you get a message on topic \" + hf . MqttGetTopic () + \": \" + message ) // we use the connection of the launcher (capsule) _ , err := hf . MqttPublish ( \"topic/reply\" , \"it's a wasm module here\" ) if err != nil { hf . Log ( \"\ud83d\ude21 ouch something bad is happening\" ) hf . Log ( err . Error ()) } } Error Management \ud83d\udd90\ud83d\udd90\ud83d\udd90 \ud83d\udea7 it's a work in progress (it's not implemented entirely) GetExitError() & GetExitCode : 1 2 3 4 5 6 //export OnExit func OnExit () { hf . Log ( \"\ud83d\udc4b\ud83e\udd17 have a nice day\" ) hf . Log ( \"Exit Error: \" + hf . GetExitError ()) hf . Log ( \"Exit Code: \" + hf . GetExitCode ()) }","title":"Host functions"},{"location":"host-functions/#host-functions","text":"\ud83d\udea7 this is a work in progress, each host function will be detailed with samples in the coming weeks. Capsule offers some capabilities to the wasm modules by providing some \"host functions\":","title":"Host functions"},{"location":"host-functions/#print-a-message","text":"1 hf . Log ( \"\ud83d\udc4b Hello World \ud83c\udf0d\" )","title":"Print a message"},{"location":"host-functions/#read-and-write-files","text":"1 2 3 4 5 6 7 8 9 10 11 txt , err := hf . ReadFile ( \"about.txt\" ) if err != nil { hf . Log ( err . Error ()) } hf . Log ( txt ) newFile , err := hf . WriteFile ( \"hello.txt\" , \"\ud83d\udc4b HELLO WORLD \ud83c\udf0d\" ) if err != nil { hf . Log ( err . Error ()) } hf . Log ( newFile )","title":"Read and Write files"},{"location":"host-functions/#read-value-of-the-environment-variables","text":"1 2 3 4 5 6 message , err := hf . GetEnv ( \"MESSAGE\" ) if err != nil { hf . Log ( err . Error ()) } else { hf . Log ( \"MESSAGE=\" + message ) }","title":"Read value of the environment variables"},{"location":"host-functions/#make-http-requests","text":"GET 1 2 3 4 5 6 ret , err := hf . Http ( \"https://httpbin.org/get\" , \"GET\" , headers , \"\" ) if err != nil { hf . Log ( \"\ud83d\ude21 error:\" + err . Error ()) } else { hf . Log ( \"\ud83d\udcddresult: \" + ret ) } POST 1 2 3 4 5 6 7 8 headers := map [ string ] string { \"Accept\" : \"application/json\" , \"Content-Type\" : \"text/html; charset=UTF-8\" } ret , err := hf . Http ( \"https://httpbin.org/post\" , \"POST\" , headers , \"\ud83d\udc4b hello world \ud83c\udf0d\" ) if err != nil { hf . Log ( \"\ud83d\ude21 error:\" + err . Error ()) } else { hf . Log ( \"\ud83d\udcddresult: \" + ret ) }","title":"Make HTTP requests"},{"location":"host-functions/#use-memory-cache","text":"MemorySet 1 _ , err := hf . MemorySet ( \"message\" , \"\ud83d\ude80 hello is started\" ) MemoryGet 1 value , err := hf . MemoryGet ( \"message\" ) MemoryKeys 1 2 3 4 5 6 7 8 9 keys , err := hf . MemoryKeys () // it will return an array of strings if err != nil { hf . Log ( err . Error ()) } for key , value := range keys { hf . Log ( key + \":\" + value ) }","title":"Use memory cache"},{"location":"host-functions/#make-redis-queries","text":"\ud83d\udea7 this is a work in progress You need to run Capsule with these two environment variables: 1 2 REDIS_ADDR = \"localhost:6379\" REDIS_PWD = \"\" SET 1 2 3 4 5 6 7 // add a key, value res , err := hf . RedisSet ( \"greetings\" , \"Hello World\" ) if err != nil { hf . Log ( err . Error ()) } else { hf . Log ( \"Value: \" + res ) } GET 1 2 3 4 5 6 7 // read the value res , err := hf . RedisGet ( \"greetings\" ) if err != nil { hf . Log ( err . Error ()) } else { hf . Log ( \"Value: \" + res ) } KEYS 1 2 3 4 5 6 7 8 legion , err := hf . RedisKeys ( \"bob*\" ) if err != nil { hf . Log ( err . Error ()) } for _ , bob := range legion { hf . Log ( bob ) }","title":"Make Redis queries"},{"location":"host-functions/#make-couchbase-n1ql-query","text":"You need to run Capsule with these four environment variables: 1 2 3 4 COUCHBASE_CLUSTER = \"couchbase://localhost\" COUCHBASE_USER = \"admin\" COUCHBASE_PWD = \"ilovepandas\" COUCHBASE_BUCKET = \"wasm-data\" 1 2 3 4 bucketName , _ := hf . GetEnv ( \"COUCHBASE_BUCKET\" ) query := \"SELECT * FROM `\" + bucketName + \"`.data.docs\" jsonStringArray , err := hf . CouchBaseQuery ( query )","title":"Make CouchBase N1QL Query"},{"location":"host-functions/#nats","text":"NatsPublish(subject string, message string) : publish a message on a subject 1 _ , err := hf . NatsPublish ( \"notify\" , \"it's a wasm module here\" ) You must use the \"nats\" mode of Capsule as the NATS connection is defined at the start of Capsule and shared with the WASM module: 1 2 3 4 5 capsule \\ -wasm = ../wasm_modules/capsule-nats-subscriber/hello.wasm \\ -mode = nats \\ -natssrv = nats.devsecops.fun:4222 \\ -subject = ping NatsReply(message string, timeout uint32) : publish a message on the current subject and wait for an answer 1 _ , err := hf . NatsReply ( \"it's a wasm module here\" , 10 ) You must use the \"nats\" mode of Capsule as the NATS connection and the subscription are defined at the start of Capsule and shared with the WASM module. NatsGetSubject() : get the subject listened by the Capsule launcher 1 hf . Log ( \"\ud83d\udc42Listening on: \" + hf . NatsGetSubject ()) NatsGetServer() : get the connected NATS server 1 hf . Log ( \"\ud83d\udc4b NATS server: \" + hf . NatsGetServer ()) NatsConnectPublish(server string, subject string, message string) : connect to a NATS server and send a message on a subject 1 _ , err := hf . NatsConnectPublish ( \"nats.devsecops.fun:4222\" , \"ping\" , \"\ud83d\udd90 Hello from WASM with Nats \ud83d\udc9c\" ) You can use this function with all the running modes of Capsule NatsConnectPublish(server string, subject string, message string, timeout uint32) : connect to a NATS server and send a message on a subject 1 answer , err := hf . NatsConnectRequest ( \"nats.devsecops.fun:4222\" , \"notify\" , \"\ud83d\udc4b Hello World \ud83c\udf0d\" , 1 ) You can use this function with all the running modes of Capsule","title":"Nats"},{"location":"host-functions/#mqtt","text":"You must use the \"mqtt\" mode of Capsule as the MQTT connection is defined at the start of Capsule and shared with the WASM module: 1 2 3 4 5 6 capsule \\ -wasm = ../wasm_modules/capsule-mqtt-subscriber/hello.wasm \\ -mode = mqtt \\ -mqttsrv = 127 .0.0.1:1883 \\ -topic = topic/sensor0 \\ -clientId = sensor_id1","title":"MQTT"},{"location":"host-functions/#mqtt-handler-as-a-subscriber","text":"\ud83d\udd90 you have to call hf.OnMqttMessage(Handle) from the main function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) // the topic is defined when launching the capsule launcher func main () { hf . OnMqttMessage ( Handle ) } func Handle ( params [] string ) { message := params [ 0 ] hf . Log ( \"\ud83d\udc4b you get a message on topic \" + hf . MqttGetTopic () + \": \" + message ) // we use the connection of the launcher (capsule) _ , err := hf . MqttPublish ( \"topic/reply\" , \"it's a wasm module here\" ) if err != nil { hf . Log ( \"\ud83d\ude21 ouch something bad is happening\" ) hf . Log ( err . Error ()) } }","title":"MQTT Handler as a Subscriber"},{"location":"host-functions/#error-management","text":"\ud83d\udd90\ud83d\udd90\ud83d\udd90 \ud83d\udea7 it's a work in progress (it's not implemented entirely) GetExitError() & GetExitCode : 1 2 3 4 5 6 //export OnExit func OnExit () { hf . Log ( \"\ud83d\udc4b\ud83e\udd17 have a nice day\" ) hf . Log ( \"Exit Error: \" + hf . GetExitError ()) hf . Log ( \"Exit Code: \" + hf . GetExitCode ()) }","title":"Error Management"},{"location":"install/","text":"Installing Capsule Before executing or running a function, you need to install the last release of Capsule : The script will install Capsule in $HOME/.local/bin if you want to install Capsule somewhere else, override the CAPSULE_PATH variable (default value: CAPSULE_PATH=\"$HOME/.local/bin\" ) \ud83d\udd90 On Linux : 1 2 export CAPSULE_VERSION = \"v0.2.8\" wget -O - https://raw.githubusercontent.com/bots-garden/capsule/ ${ CAPSULE_VERSION } /install-capsule-launcher.sh | bash \ud83d\udd90 On macOS : create the $HOME/.local/bin directory add it to your path: 1 2 export CAPSULE_RUNNER_PATH = \" $HOME /.local\" export PATH = \" $CAPSULE_RUNNER_PATH /bin: $PATH \" Then you can serve a wasm function like this: 1 2 3 4 MESSAGE = \"\ud83d\udc4b Hello World \ud83c\udf0d\" capsule \\ -wasm = ./app/index.wasm \\ -mode = http \\ -httpPort = 8080 You can download the appropriate release of Capsule here: v0.2.8 \ud83e\udda4 [dodo] Using the Capsule Docker image The documentation is a wip \ud83d\udea7 A \"scratch\" Docker image of Capsule exists on https://hub.docker.com/r/k33g/capsule-launcher/tags . You can find more details on the capsule-docker-image project. This image will be used to deploy Capsule to CaaS or Kubernetes. You can use it directly to run a wasm function without installing Capsule: 1 2 3 4 5 6 7 8 docker run \\ -p 8080 :8080 \\ -e MESSAGE = \"\ud83d\udc4b Hello World \ud83c\udf0d\" \\ -v $( pwd ) :/app --rm k33g/capsule-launcher:0.2.8 \\ /capsule \\ -wasm = ./app/index.wasm \\ -mode = http \\ -httpPort = 8080 \ud83d\udc4b You will find some running examples with these projects: https://github.com/bots-garden/capsule-launcher-demo https://github.com/bots-garden/capsule-hello-universe Old samples to be updated: https://github.com/bots-garden/capsule-samples https://github.com/bots-garden/capsule-on-fly-dot-io","title":"Install"},{"location":"install/#installing-capsule","text":"Before executing or running a function, you need to install the last release of Capsule : The script will install Capsule in $HOME/.local/bin if you want to install Capsule somewhere else, override the CAPSULE_PATH variable (default value: CAPSULE_PATH=\"$HOME/.local/bin\" ) \ud83d\udd90 On Linux : 1 2 export CAPSULE_VERSION = \"v0.2.8\" wget -O - https://raw.githubusercontent.com/bots-garden/capsule/ ${ CAPSULE_VERSION } /install-capsule-launcher.sh | bash \ud83d\udd90 On macOS : create the $HOME/.local/bin directory add it to your path: 1 2 export CAPSULE_RUNNER_PATH = \" $HOME /.local\" export PATH = \" $CAPSULE_RUNNER_PATH /bin: $PATH \" Then you can serve a wasm function like this: 1 2 3 4 MESSAGE = \"\ud83d\udc4b Hello World \ud83c\udf0d\" capsule \\ -wasm = ./app/index.wasm \\ -mode = http \\ -httpPort = 8080 You can download the appropriate release of Capsule here: v0.2.8 \ud83e\udda4 [dodo]","title":"Installing Capsule"},{"location":"install/#using-the-capsule-docker-image","text":"The documentation is a wip \ud83d\udea7 A \"scratch\" Docker image of Capsule exists on https://hub.docker.com/r/k33g/capsule-launcher/tags . You can find more details on the capsule-docker-image project. This image will be used to deploy Capsule to CaaS or Kubernetes. You can use it directly to run a wasm function without installing Capsule: 1 2 3 4 5 6 7 8 docker run \\ -p 8080 :8080 \\ -e MESSAGE = \"\ud83d\udc4b Hello World \ud83c\udf0d\" \\ -v $( pwd ) :/app --rm k33g/capsule-launcher:0.2.8 \\ /capsule \\ -wasm = ./app/index.wasm \\ -mode = http \\ -httpPort = 8080 \ud83d\udc4b You will find some running examples with these projects: https://github.com/bots-garden/capsule-launcher-demo https://github.com/bots-garden/capsule-hello-universe Old samples to be updated: https://github.com/bots-garden/capsule-samples https://github.com/bots-garden/capsule-on-fly-dot-io","title":"Using the Capsule Docker image"},{"location":"references/","text":"References Blog posts Create a GitLab bot with a Capsule Wasm function in less than 100 lines of code Deploy Capsule Functions on Fly.io in a flash A simple calc serverless function with Capsule, NATS and Node.js Host and Serve a Lit SPA with WebAssembly (and Capsule) Capsule, my personal wasm FaaS (part 2) Capsule, my personal wasm multi-tools knife (part 1) Extend Wasm with host functions thanks to Wazero An essay on the bi-directional exchange of strings between the Wasm module (with TinyGo) and Node.js (with WASI support)","title":"Refs"},{"location":"references/#references","text":"","title":"References"},{"location":"references/#blog-posts","text":"Create a GitLab bot with a Capsule Wasm function in less than 100 lines of code Deploy Capsule Functions on Fly.io in a flash A simple calc serverless function with Capsule, NATS and Node.js Host and Serve a Lit SPA with WebAssembly (and Capsule) Capsule, my personal wasm FaaS (part 2) Capsule, my personal wasm multi-tools knife (part 1) Extend Wasm with host functions thanks to Wazero An essay on the bi-directional exchange of strings between the Wasm module (with TinyGo) and Node.js (with WASI support)","title":"Blog posts"},{"location":"tooling/","text":"Tooling The documentation is a wip \ud83d\udea7 To write and build wasm function for Capsule, you need to install GoLang and TinyGo. Otherwise, you can use the capsule-function-builder project. It provides a very simple CLI, named capsule-builder or cabu that uses a Docker image with all the necessary resources (Golang and TinyGo compilers). Install Capsule Builder 1 2 CAPSULE_BUILDER_VERSION = \"v0.0.2\" wget -O - https://raw.githubusercontent.com/bots-garden/capsule-function-builder/ ${ CAPSULE_BUILDER_VERSION } /install-capsule-builder.sh | bash Then you can generate a new project from a template: 1 2 3 # template name: `service-get` # function project name `hello-world` cabu generate service-get hello-world Then, build it easily: 1 2 cd hello-world cabu build . hello-world.go hello-world.wasm And, finally, serve it: 1 2 3 4 capsule \\ -wasm = ./hello-world.wasm \\ -mode = http \\ -httpPort = 8080","title":"Tooling"},{"location":"tooling/#tooling","text":"The documentation is a wip \ud83d\udea7 To write and build wasm function for Capsule, you need to install GoLang and TinyGo. Otherwise, you can use the capsule-function-builder project. It provides a very simple CLI, named capsule-builder or cabu that uses a Docker image with all the necessary resources (Golang and TinyGo compilers).","title":"Tooling"},{"location":"tooling/#install-capsule-builder","text":"1 2 CAPSULE_BUILDER_VERSION = \"v0.0.2\" wget -O - https://raw.githubusercontent.com/bots-garden/capsule-function-builder/ ${ CAPSULE_BUILDER_VERSION } /install-capsule-builder.sh | bash Then you can generate a new project from a template: 1 2 3 # template name: `service-get` # function project name `hello-world` cabu generate service-get hello-world Then, build it easily: 1 2 cd hello-world cabu build . hello-world.go hello-world.wasm And, finally, serve it: 1 2 3 4 capsule \\ -wasm = ./hello-world.wasm \\ -mode = http \\ -httpPort = 8080","title":"Install Capsule Builder"}]}