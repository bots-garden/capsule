{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Capsule: the nano (wasm) functions runner What's new? v0.2.9 \ud83e\udd9c [parrot] : Hot reloading of the wasm module see the \"Reload the module\" section and HTTP service refactoring. v0.2.8 \ud83e\udda4 [dodo] : Capsule uses now Fiber instead Gin . The size of the Capsule Runner Docker image is now 16.8M! What is Capsule ? Capsule is a WebAssembly Function Runner . It means that Capsule is both: An HTTP server that serves WebAssembly functions A NATS subscriber and publisher (written with WebAssembly) A MQTT subscriber and publisher (written with WebAssembly) A CLI , you can simply execute a WASM function in a terminal Capsule is developed with GoLang and thanks to the \ud83d\udc9c Wazero project The wasm modules are developed in GoLang and compiled with TinyGo \ud83d\udc9c (with the WASI specification) What does a WASM function look like with Capsule? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . SetHandleHttp ( Handle ) } func Handle ( request hf . Request ) ( response hf . Response , errResp error ) { headersResp := map [ string ] string { \"Content-Type\" : \"application/json; charset=utf-8\" , } jsondoc := `{\"message\": \"\ud83d\udc4b Hello World \ud83c\udf0d\"}` return hf . Response { Body : jsondoc , Headers : headersResp }, err } What are the added values of Capsule? Capsule brings superpowers to the WASM function modules with host functions . Thanks to these host functions , a WASM function can, for example, prints a message, reads files, writes to files, makes HTTP requests, ... See the host functions section . Useful information for this project \ud83d\udd90 Issues: https://github.com/bots-garden/capsule/issues \ud83d\udce6 Last release: v0.2.9 \ud83e\udd9c [parrot] \ud83d\udce6 Next release: v0.3.0 \ud83c\udf85 [santa] \ud83d\udea7 in progress \ud83d\udce6 Releases: https://github.com/bots-garden/capsule/releases","title":"\ud83c\udfe0 Home"},{"location":"#capsule-the-nano-wasm-functions-runner","text":"What's new? v0.2.9 \ud83e\udd9c [parrot] : Hot reloading of the wasm module see the \"Reload the module\" section and HTTP service refactoring. v0.2.8 \ud83e\udda4 [dodo] : Capsule uses now Fiber instead Gin . The size of the Capsule Runner Docker image is now 16.8M!","title":"Capsule: the nano (wasm) functions runner"},{"location":"#what-is-capsule","text":"Capsule is a WebAssembly Function Runner . It means that Capsule is both: An HTTP server that serves WebAssembly functions A NATS subscriber and publisher (written with WebAssembly) A MQTT subscriber and publisher (written with WebAssembly) A CLI , you can simply execute a WASM function in a terminal Capsule is developed with GoLang and thanks to the \ud83d\udc9c Wazero project The wasm modules are developed in GoLang and compiled with TinyGo \ud83d\udc9c (with the WASI specification)","title":"What is Capsule?"},{"location":"#what-does-a-wasm-function-look-like-with-capsule","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . SetHandleHttp ( Handle ) } func Handle ( request hf . Request ) ( response hf . Response , errResp error ) { headersResp := map [ string ] string { \"Content-Type\" : \"application/json; charset=utf-8\" , } jsondoc := `{\"message\": \"\ud83d\udc4b Hello World \ud83c\udf0d\"}` return hf . Response { Body : jsondoc , Headers : headersResp }, err }","title":"What does a WASM function look like with Capsule?"},{"location":"#what-are-the-added-values-of-capsule","text":"Capsule brings superpowers to the WASM function modules with host functions . Thanks to these host functions , a WASM function can, for example, prints a message, reads files, writes to files, makes HTTP requests, ... See the host functions section . Useful information for this project \ud83d\udd90 Issues: https://github.com/bots-garden/capsule/issues \ud83d\udce6 Last release: v0.2.9 \ud83e\udd9c [parrot] \ud83d\udce6 Next release: v0.3.0 \ud83c\udf85 [santa] \ud83d\udea7 in progress \ud83d\udce6 Releases: https://github.com/bots-garden/capsule/releases","title":"What are the added values of Capsule?"},{"location":"capsule-faas/","text":"Capsule FaaS (experimental) There are four additional components to use Capsule (the wasm module launcher/executor) in FaaS mode: capsule-registry : a wasm module registry (\ud83d\udea7 support of https://wapm.io/ in progress) capsule-reverse-proxy : a reverse-proxy to simplify the functions (wasm modules) access capsule-worker : a server to start the functions (wasm modules) remotely capsule-ctl (short name: caps ): a CLI to facilitate the interaction with the worker You can use the capsule registry independently of FaaS mode, only to provide wasm modules to the capsule launcher You can use the capsule reverse-proxy independently of FaaS mode, only to get only one access URL","title":"\ud83e\uddea Capsule FaaS"},{"location":"capsule-faas/#capsule-faas-experimental","text":"There are four additional components to use Capsule (the wasm module launcher/executor) in FaaS mode: capsule-registry : a wasm module registry (\ud83d\udea7 support of https://wapm.io/ in progress) capsule-reverse-proxy : a reverse-proxy to simplify the functions (wasm modules) access capsule-worker : a server to start the functions (wasm modules) remotely capsule-ctl (short name: caps ): a CLI to facilitate the interaction with the worker You can use the capsule registry independently of FaaS mode, only to provide wasm modules to the capsule launcher You can use the capsule reverse-proxy independently of FaaS mode, only to get only one access URL","title":"Capsule FaaS (experimental)"},{"location":"cookbook-civo/","text":"\ud83e\udd58 CookBook Deploy a Capsule function on Civo What is Civo? Civo is a cloud native service provider. They are doing K3S as a service and the UX is just amazing \ud83d\ude0d Requirements First, you need an account on Civo , then you will need to install some tools. The install commands I used were tested on macOs and Ubuntu. I'm using brew , but there are severeal other ways to install all the needed tools. kubectl : 1 brew install kubernetes-cli Civo CLI : 1 2 brew tap civo/tools brew install civo K9s : (optional, but K9s is a great tool, very useful to manage your cluster) 1 brew install derailed/k9s/k9s Create a K3s cluster on Civo In order to use the Civo CLI you will need to authenticate yourself to the Civo API using a key. You can find the key or regenerate a new one at https://www.civo.com/api . Save your key in an environment variable: CIVO_API_KEY . And then use the below commands to create a cluster on Civo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 CLUSTER_NAME = \"tinypanda\" CLUSTER_SIZE = \"g4s.kube.xsmall\" CLUSTER_NODES = 1 CLUSTER_REGION = \"FRA1\" mkdir -p config export KUBECONFIG = $PWD /config/k3s.yaml # Add the key to the CLI tool civo apikey add civo-key ${ CIVO_API_KEY } civo apikey current civo-key # Create the cluster civo kubernetes create ${ CLUSTER_NAME } \\ --size = ${ CLUSTER_SIZE } \\ --nodes = ${ CLUSTER_NODES } \\ --region = ${ CLUSTER_REGION } \\ --wait # Get the kubernetes config file civo --region = ${ CLUSTER_REGION } \\ kubernetes config ${ CLUSTER_NAME } > ./config/k3s.yaml Output : 1 2 3 4 5 6 Saved the API Key civo-key Set the default API Key to be civo-key Creating a 1 node k3s cluster of g4s.kube.xsmall instances called tinypanda... The cluster tinypanda ( af4abac9-6fff-463d-b89d-dfc51cdf3333 ) has been created in 1 min 10 sec Look at your cluster You can use K9s to check your new cluster with the below commands: 1 2 export KUBECONFIG = $PWD /config/k3s.yaml k9s --all-namespaces Create a new Capsule function hello.go : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"github.com/tidwall/gjson\" \"github.com/tidwall/sjson\" ) func main () { hf . SetHandleHttp ( Handle ) } func Handle ( request hf . Request ) ( response hf . Response , errResp error ) { name := gjson . Get ( request . Body , \"name\" ) headersResp := map [ string ] string { \"Content-Type\" : \"application/json; charset=utf-8\" , } jsondoc := `{\"message\": \"\"}` jsondoc , _ = sjson . Set ( jsondoc , \"message\" , \"\ud83d\udc4b hello \" + name . Str ) return hf . Response { Body : jsondoc , Headers : headersResp }, nil } go.mod : 1 2 3 module hello go 1.18 Dockerize the function Dockerfile : 1 2 3 4 5 6 7 8 9 10 FROM k33g/capsule-builder:0.0.3 COPY go.mod ./ COPY hello.go ./ RUN go get -u ./... ; go mod tidy ; RUN tinygo build -o hello.wasm -target wasi hello.go FROM k33g/capsule-launcher:0.2.9 COPY --from = 0 /home/function/hello.wasm ./ EXPOSE 8080 CMD [ \"/capsule\" , \"-wasm=./hello.wasm\" , \"-mode=http\" , \"-httpPort=8080\" ] We use multi-stage builds to first build the wasm function and then to create the smallest image as possible to serve the function. Build and push the Docker image to the Docker Hub Build the image: 1 2 3 4 5 6 7 IMAGE_NAME = \"capsule-hello\" IMAGE_TAG = \"0.0.0\" docker login -u ${ DOCKER_USER } -p ${ DOCKER_PWD } docker build -t ${ IMAGE_NAME } . docker images | grep ${ IMAGE_NAME } Push to the Docker hub: 1 2 3 4 5 IMAGE_NAME = \"capsule-hello\" IMAGE_TAG = \"0.0.0\" docker tag ${ IMAGE_NAME } ${ DOCKER_USER } / ${ IMAGE_NAME } : ${ IMAGE_TAG } docker push ${ DOCKER_USER } / ${ IMAGE_NAME } : ${ IMAGE_TAG } Test the image 1 2 3 IMAGE_NAME = \"capsule-hello\" IMAGE_TAG = \"0.0.0\" docker run -p 8080 :8080 --rm ${ DOCKER_USER } / ${ IMAGE_NAME } : ${ IMAGE_TAG } Output : 1 \ud83d\udc8a Capsule ( v0.2.9 \ud83e\udd9c [ parrot ] ) http server is listening on: 8080 \ud83c\udf0d Test your deployed function : 1 2 3 curl -v -X POST http://localhost:8080 \\ -H 'content-type: application/json' \\ -d '{\"name\": \"Bob\"}' Output : 1 { \"message\" : \"\ud83d\udc4b hello Bob\" } Create the manifest to deploy the function Some information Before creating the manifest we need some information: 1 2 3 4 CLUSTER_NAME = \"tinypanda\" CLUSTER_REGION = \"FRA1\" civo --region = ${ CLUSTER_REGION } kubernetes show ${ CLUSTER_NAME } Output : 1 2 3 4 5 6 7 8 9 10 11 12 ID : af4abac9-6fff-463d-b89d-dfc51cdf3333 Name : tinypanda Region : FRA1 Nodes : 1 Size : g4s.kube.xsmall Status : ACTIVE Firewall : k3s-cluster-tinypanda-a39c-dce40a Version : 1 .23.6-k3s1 API Endpoint : https://74.220.24.41:6443 External IP : 74 .220.24.41 DNS A record : af4abac9-6fff-463d-b89d-dfc51cdf3333.k8s.civo.com Installed Applications : metrics-server, Traefik-v2-nodeport \ud83d\udd90 save this information somewhere : DNS A record : af4abac9-6fff-463d-b89d-dfc51cdf3333.k8s.civo.com , you will use it to the host value of the Ingress section of the manifest. The name of our application will be capsule-hello , then url to reach it will be capsule-hello.af4abac9-6fff-463d-b89d-dfc51cdf3333.k8s.civo.com . Deployment manifest Now, create a deployment manifest: deploy.hello.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 --- # Service apiVersion : v1 kind : Service metadata : name : capsule-hello spec : selector : app : capsule-hello ports : - port : 8080 targetPort : 8080 --- # Deployment apiVersion : apps/v1 kind : Deployment metadata : name : capsule-hello spec : replicas : 1 selector : matchLabels : app : capsule-hello template : metadata : labels : app : capsule-hello spec : containers : - name : capsule-hello image : k33g/capsule-hello:0.0.0 ports : - containerPort : 8080 imagePullPolicy : Always --- # Ingress apiVersion : networking.k8s.io/v1 kind : Ingress metadata : name : capsule-hello spec : rules : - host : capsule-hello.af4abac9-6fff-463d-b89d-dfc51cdf3333.k8s.civo.com http : paths : - path : / pathType : Prefix backend : service : name : capsule-hello port : number : 8080 Deploy \ud83d\ude80 Run the below commands to deploy the function on the Civo cluster: 1 2 3 4 5 6 export KUBECONFIG = $PWD /config/k3s.yaml # Create a demo namespace export KUBE_NAMESPACE = \"demo\" kubectl create namespace ${ KUBE_NAMESPACE } --dry-run = client -o yaml | kubectl apply -f - kubectl apply -f deploy.hello.yaml -n ${ KUBE_NAMESPACE } Output : 1 2 3 4 namespace/demo created service/capsule-hello created deployment.apps/capsule-hello created ingress.networking.k8s.io/capsule-hello created You can see in K9s that you get a new pod: Call the function You can now use your new function 1 2 3 4 5 6 export APPLICATION_NAME = \"capsule-hello\" export DNS = \"af4abac9-6fff-463d-b89d-dfc51cdf3333.k8s.civo.com\" curl http:// ${ APPLICATION_NAME } . ${ DNS } -H 'content-type: application/json' -d '{\"name\": \"Jane Doe\"}' curl http:// ${ APPLICATION_NAME } . ${ DNS } -H 'content-type: application/json' -d '{\"name\": \"John Doe\"}' curl http:// ${ APPLICATION_NAME } . ${ DNS } -H 'content-type: application/json' -d '{\"name\": \"Bob Morane\"}' Output : 1 { \"message\" : \"\ud83d\udc4b hello Jane Doe\" }{ \"message\" : \"\ud83d\udc4b hello John Doe\" }{ \"message\" : \"\ud83d\udc4b hello Bob Morane\" } \ud83c\udf89 You see, that was pretty straightforward to do and easy to reproduce. How to delete the cluster? 1 civo kubernetes remove ${ CLUSTER_NAME } --region = ${ CLUSTER_REGION } --yes","title":"Capsule function on Civo"},{"location":"cookbook-civo/#cookbook","text":"","title":"\ud83e\udd58 CookBook"},{"location":"cookbook-civo/#deploy-a-capsule-function-on-civo","text":"What is Civo? Civo is a cloud native service provider. They are doing K3S as a service and the UX is just amazing \ud83d\ude0d","title":"Deploy a Capsule function on Civo"},{"location":"cookbook-civo/#requirements","text":"First, you need an account on Civo , then you will need to install some tools. The install commands I used were tested on macOs and Ubuntu. I'm using brew , but there are severeal other ways to install all the needed tools. kubectl : 1 brew install kubernetes-cli Civo CLI : 1 2 brew tap civo/tools brew install civo K9s : (optional, but K9s is a great tool, very useful to manage your cluster) 1 brew install derailed/k9s/k9s","title":"Requirements"},{"location":"cookbook-civo/#create-a-k3s-cluster-on-civo","text":"In order to use the Civo CLI you will need to authenticate yourself to the Civo API using a key. You can find the key or regenerate a new one at https://www.civo.com/api . Save your key in an environment variable: CIVO_API_KEY . And then use the below commands to create a cluster on Civo: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 CLUSTER_NAME = \"tinypanda\" CLUSTER_SIZE = \"g4s.kube.xsmall\" CLUSTER_NODES = 1 CLUSTER_REGION = \"FRA1\" mkdir -p config export KUBECONFIG = $PWD /config/k3s.yaml # Add the key to the CLI tool civo apikey add civo-key ${ CIVO_API_KEY } civo apikey current civo-key # Create the cluster civo kubernetes create ${ CLUSTER_NAME } \\ --size = ${ CLUSTER_SIZE } \\ --nodes = ${ CLUSTER_NODES } \\ --region = ${ CLUSTER_REGION } \\ --wait # Get the kubernetes config file civo --region = ${ CLUSTER_REGION } \\ kubernetes config ${ CLUSTER_NAME } > ./config/k3s.yaml Output : 1 2 3 4 5 6 Saved the API Key civo-key Set the default API Key to be civo-key Creating a 1 node k3s cluster of g4s.kube.xsmall instances called tinypanda... The cluster tinypanda ( af4abac9-6fff-463d-b89d-dfc51cdf3333 ) has been created in 1 min 10 sec","title":"Create a K3s cluster on Civo"},{"location":"cookbook-civo/#look-at-your-cluster","text":"You can use K9s to check your new cluster with the below commands: 1 2 export KUBECONFIG = $PWD /config/k3s.yaml k9s --all-namespaces","title":"Look at your cluster"},{"location":"cookbook-civo/#create-a-new-capsule-function","text":"hello.go : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"github.com/tidwall/gjson\" \"github.com/tidwall/sjson\" ) func main () { hf . SetHandleHttp ( Handle ) } func Handle ( request hf . Request ) ( response hf . Response , errResp error ) { name := gjson . Get ( request . Body , \"name\" ) headersResp := map [ string ] string { \"Content-Type\" : \"application/json; charset=utf-8\" , } jsondoc := `{\"message\": \"\"}` jsondoc , _ = sjson . Set ( jsondoc , \"message\" , \"\ud83d\udc4b hello \" + name . Str ) return hf . Response { Body : jsondoc , Headers : headersResp }, nil } go.mod : 1 2 3 module hello go 1.18","title":"Create a new Capsule function"},{"location":"cookbook-civo/#dockerize-the-function","text":"Dockerfile : 1 2 3 4 5 6 7 8 9 10 FROM k33g/capsule-builder:0.0.3 COPY go.mod ./ COPY hello.go ./ RUN go get -u ./... ; go mod tidy ; RUN tinygo build -o hello.wasm -target wasi hello.go FROM k33g/capsule-launcher:0.2.9 COPY --from = 0 /home/function/hello.wasm ./ EXPOSE 8080 CMD [ \"/capsule\" , \"-wasm=./hello.wasm\" , \"-mode=http\" , \"-httpPort=8080\" ] We use multi-stage builds to first build the wasm function and then to create the smallest image as possible to serve the function.","title":"Dockerize the function"},{"location":"cookbook-civo/#build-and-push-the-docker-image-to-the-docker-hub","text":"Build the image: 1 2 3 4 5 6 7 IMAGE_NAME = \"capsule-hello\" IMAGE_TAG = \"0.0.0\" docker login -u ${ DOCKER_USER } -p ${ DOCKER_PWD } docker build -t ${ IMAGE_NAME } . docker images | grep ${ IMAGE_NAME } Push to the Docker hub: 1 2 3 4 5 IMAGE_NAME = \"capsule-hello\" IMAGE_TAG = \"0.0.0\" docker tag ${ IMAGE_NAME } ${ DOCKER_USER } / ${ IMAGE_NAME } : ${ IMAGE_TAG } docker push ${ DOCKER_USER } / ${ IMAGE_NAME } : ${ IMAGE_TAG }","title":"Build and push the Docker image to the Docker Hub"},{"location":"cookbook-civo/#test-the-image","text":"1 2 3 IMAGE_NAME = \"capsule-hello\" IMAGE_TAG = \"0.0.0\" docker run -p 8080 :8080 --rm ${ DOCKER_USER } / ${ IMAGE_NAME } : ${ IMAGE_TAG } Output : 1 \ud83d\udc8a Capsule ( v0.2.9 \ud83e\udd9c [ parrot ] ) http server is listening on: 8080 \ud83c\udf0d Test your deployed function : 1 2 3 curl -v -X POST http://localhost:8080 \\ -H 'content-type: application/json' \\ -d '{\"name\": \"Bob\"}' Output : 1 { \"message\" : \"\ud83d\udc4b hello Bob\" }","title":"Test the image"},{"location":"cookbook-civo/#create-the-manifest-to-deploy-the-function","text":"","title":"Create the manifest to deploy the function"},{"location":"cookbook-civo/#some-information","text":"Before creating the manifest we need some information: 1 2 3 4 CLUSTER_NAME = \"tinypanda\" CLUSTER_REGION = \"FRA1\" civo --region = ${ CLUSTER_REGION } kubernetes show ${ CLUSTER_NAME } Output : 1 2 3 4 5 6 7 8 9 10 11 12 ID : af4abac9-6fff-463d-b89d-dfc51cdf3333 Name : tinypanda Region : FRA1 Nodes : 1 Size : g4s.kube.xsmall Status : ACTIVE Firewall : k3s-cluster-tinypanda-a39c-dce40a Version : 1 .23.6-k3s1 API Endpoint : https://74.220.24.41:6443 External IP : 74 .220.24.41 DNS A record : af4abac9-6fff-463d-b89d-dfc51cdf3333.k8s.civo.com Installed Applications : metrics-server, Traefik-v2-nodeport \ud83d\udd90 save this information somewhere : DNS A record : af4abac9-6fff-463d-b89d-dfc51cdf3333.k8s.civo.com , you will use it to the host value of the Ingress section of the manifest. The name of our application will be capsule-hello , then url to reach it will be capsule-hello.af4abac9-6fff-463d-b89d-dfc51cdf3333.k8s.civo.com .","title":"Some information"},{"location":"cookbook-civo/#deployment-manifest","text":"Now, create a deployment manifest: deploy.hello.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 --- # Service apiVersion : v1 kind : Service metadata : name : capsule-hello spec : selector : app : capsule-hello ports : - port : 8080 targetPort : 8080 --- # Deployment apiVersion : apps/v1 kind : Deployment metadata : name : capsule-hello spec : replicas : 1 selector : matchLabels : app : capsule-hello template : metadata : labels : app : capsule-hello spec : containers : - name : capsule-hello image : k33g/capsule-hello:0.0.0 ports : - containerPort : 8080 imagePullPolicy : Always --- # Ingress apiVersion : networking.k8s.io/v1 kind : Ingress metadata : name : capsule-hello spec : rules : - host : capsule-hello.af4abac9-6fff-463d-b89d-dfc51cdf3333.k8s.civo.com http : paths : - path : / pathType : Prefix backend : service : name : capsule-hello port : number : 8080","title":"Deployment manifest"},{"location":"cookbook-civo/#deploy","text":"Run the below commands to deploy the function on the Civo cluster: 1 2 3 4 5 6 export KUBECONFIG = $PWD /config/k3s.yaml # Create a demo namespace export KUBE_NAMESPACE = \"demo\" kubectl create namespace ${ KUBE_NAMESPACE } --dry-run = client -o yaml | kubectl apply -f - kubectl apply -f deploy.hello.yaml -n ${ KUBE_NAMESPACE } Output : 1 2 3 4 namespace/demo created service/capsule-hello created deployment.apps/capsule-hello created ingress.networking.k8s.io/capsule-hello created You can see in K9s that you get a new pod:","title":"Deploy \ud83d\ude80"},{"location":"cookbook-civo/#call-the-function","text":"You can now use your new function 1 2 3 4 5 6 export APPLICATION_NAME = \"capsule-hello\" export DNS = \"af4abac9-6fff-463d-b89d-dfc51cdf3333.k8s.civo.com\" curl http:// ${ APPLICATION_NAME } . ${ DNS } -H 'content-type: application/json' -d '{\"name\": \"Jane Doe\"}' curl http:// ${ APPLICATION_NAME } . ${ DNS } -H 'content-type: application/json' -d '{\"name\": \"John Doe\"}' curl http:// ${ APPLICATION_NAME } . ${ DNS } -H 'content-type: application/json' -d '{\"name\": \"Bob Morane\"}' Output : 1 { \"message\" : \"\ud83d\udc4b hello Jane Doe\" }{ \"message\" : \"\ud83d\udc4b hello John Doe\" }{ \"message\" : \"\ud83d\udc4b hello Bob Morane\" } \ud83c\udf89 You see, that was pretty straightforward to do and easy to reproduce. How to delete the cluster? 1 civo kubernetes remove ${ CLUSTER_NAME } --region = ${ CLUSTER_REGION } --yes","title":"Call the function"},{"location":"cookbook-fly/","text":"\ud83e\udd58 CookBook Deploy a Capsule function on Fly.io What is Fly.io? Fly is a platform for running full stack apps and databases. It's a very very easy way to deploy a container. Requirements First, you need an account on Fly.io , then you will need to install some tools. The install commands I used were tested on macOs and Ubuntu. I'm using brew , but there are severeal other ways to install all the needed tools. flyctl, the Fly.io CLI : 1 brew install superfly/tap/flyctl Get your token from your Fly.io account, and set a FLY_ACCESS_TOKEN variable with the token's value. Create a new Capsule function hello.go : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"github.com/tidwall/gjson\" \"github.com/tidwall/sjson\" ) func main () { hf . SetHandleHttp ( Handle ) } func Handle ( request hf . Request ) ( response hf . Response , errResp error ) { name := gjson . Get ( request . Body , \"name\" ) headersResp := map [ string ] string { \"Content-Type\" : \"application/json; charset=utf-8\" , } jsondoc := `{\"message\": \"\"}` jsondoc , _ = sjson . Set ( jsondoc , \"message\" , \"\ud83d\udc4b hello \" + name . Str ) return hf . Response { Body : jsondoc , Headers : headersResp }, nil } go.mod : 1 2 3 module hello go 1.18 Dockerize the function In the directory of the function, create a Dockerfile : Dockerfile : 1 2 3 4 FROM k33g/capsule-launcher:0.2.9 ADD hello.wasm ./ EXPOSE 8080 CMD [ \"/capsule\" , \"-wasm=./hello.wasm\" , \"-mode=http\" , \"-httpPort=8080\" ] Build the function Then build the wasm module with TinyGo 1 tinygo build -o hello.wasm -scheduler = none -target wasi ./hello.go If you don't want to install all the toolchain (Go, TinyGo) you can install CaBu and compile the wasm module like this: 1 cabu build . hello.go hello.wasm or use multi-stage builds to first build the wasm function and then to create the smallest image as possible to serve the function. \ud83d\udc40 Look at Capsule function on Civo . Build and push the Docker image Build the Docker image Type the below commands to build the Docker image: 1 2 3 IMAGE_NAME = \"capsule-hello-demo\" IMAGE_TAG = \"0.0.0\" docker build -t ${ IMAGE_NAME } . Test it Run the below command: 1 docker run -p 8080 :8080 -it ${ IMAGE_NAME } Then call the function: 1 2 3 curl -X POST http://localhost:8080 \\ -H 'content-type: application/json' \\ -d '{\"name\": \"Bob\"}' You should get: {\"message\":\"\ud83d\udc4b hello Bob\"} Push the Docker image to the Docker Hub Type the below commands to publish the Docker image: 1 2 3 4 5 IMAGE_NAME = \"capsule-hello-demo\" IMAGE_TAG = \"0.0.0\" docker login -u ${ DOCKER_USER } -p ${ DOCKER_PWD } docker tag ${ IMAGE_NAME } ${ DOCKER_USER } / ${ IMAGE_NAME } : ${ IMAGE_TAG } docker push ${ DOCKER_USER } / ${ IMAGE_NAME } : ${ IMAGE_TAG } \ud83d\ude80 Deploy the function on Fly.io Before the first deployment, you need to create the application on Fly.io : 1 2 3 # Create the application, only at the first deployment APPLICATION_NAME = \"capsule-hello-demo\" flyctl apps create ${ APPLICATION_NAME } --json And then, run the below commands to deploy the function: 1 2 3 4 5 6 7 8 IMAGE_NAME = \"capsule-hello-demo\" IMAGE_TAG = \"0.0.0\" APPLICATION_NAME = \"capsule-hello-demo\" flyctl deploy \\ --app ${ APPLICATION_NAME } \\ --image ${ DOCKER_USER } / ${ IMAGE_NAME } : ${ IMAGE_TAG } \\ --verbose --json Output : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 == > Verifying app config --> Verified app config == > Building image Searching for image 'k33g/capsule-hello-demo:0.0.3' remotely... image found: img_ox20prmgxx3vj1zq == > Creating release --> release v2 created --> You can detach the terminal anytime without stopping the deployment == > Monitoring deployment 1 desired, 1 placed, 0 healthy, 0 unhealthy [ health checks: 1 total, 1 pa 1 desired, 1 placed, 1 healthy, 0 unhealthy [ health checks: 1 total, 1 pa 1 desired, 1 placed, 1 healthy, 0 unhealthy [ health checks: 1 total, 1 passing ] --> v0 deployed successfully The function is deployed \ud83c\udf89 Test the function Run the below commands: 1 2 3 4 5 6 7 APPLICATION_NAME = \"capsule-hello-demo\" # The function url follows the following form: URL = \"https:// ${ {APPLICATION_NAME } }.fly.dev\" curl -X POST ${ URL } \\ -H 'content-type: application/json' \\ -d '{\"name\": \"Bob\"}' You should get: {\"message\":\"\ud83d\udc4b hello Bob\"} \ud83c\udf89 Fly.io is an excellent option for deploying a container with ease.","title":"Capsule function on Fly.yo"},{"location":"cookbook-fly/#cookbook","text":"","title":"\ud83e\udd58 CookBook"},{"location":"cookbook-fly/#deploy-a-capsule-function-on-flyio","text":"What is Fly.io? Fly is a platform for running full stack apps and databases. It's a very very easy way to deploy a container.","title":"Deploy a Capsule function on Fly.io"},{"location":"cookbook-fly/#requirements","text":"First, you need an account on Fly.io , then you will need to install some tools. The install commands I used were tested on macOs and Ubuntu. I'm using brew , but there are severeal other ways to install all the needed tools. flyctl, the Fly.io CLI : 1 brew install superfly/tap/flyctl Get your token from your Fly.io account, and set a FLY_ACCESS_TOKEN variable with the token's value.","title":"Requirements"},{"location":"cookbook-fly/#create-a-new-capsule-function","text":"hello.go : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"github.com/tidwall/gjson\" \"github.com/tidwall/sjson\" ) func main () { hf . SetHandleHttp ( Handle ) } func Handle ( request hf . Request ) ( response hf . Response , errResp error ) { name := gjson . Get ( request . Body , \"name\" ) headersResp := map [ string ] string { \"Content-Type\" : \"application/json; charset=utf-8\" , } jsondoc := `{\"message\": \"\"}` jsondoc , _ = sjson . Set ( jsondoc , \"message\" , \"\ud83d\udc4b hello \" + name . Str ) return hf . Response { Body : jsondoc , Headers : headersResp }, nil } go.mod : 1 2 3 module hello go 1.18","title":"Create a new Capsule function"},{"location":"cookbook-fly/#dockerize-the-function","text":"In the directory of the function, create a Dockerfile : Dockerfile : 1 2 3 4 FROM k33g/capsule-launcher:0.2.9 ADD hello.wasm ./ EXPOSE 8080 CMD [ \"/capsule\" , \"-wasm=./hello.wasm\" , \"-mode=http\" , \"-httpPort=8080\" ]","title":"Dockerize the function"},{"location":"cookbook-fly/#build-the-function","text":"Then build the wasm module with TinyGo 1 tinygo build -o hello.wasm -scheduler = none -target wasi ./hello.go If you don't want to install all the toolchain (Go, TinyGo) you can install CaBu and compile the wasm module like this: 1 cabu build . hello.go hello.wasm or use multi-stage builds to first build the wasm function and then to create the smallest image as possible to serve the function. \ud83d\udc40 Look at Capsule function on Civo .","title":"Build the function"},{"location":"cookbook-fly/#build-and-push-the-docker-image","text":"","title":"Build and push the Docker image"},{"location":"cookbook-fly/#build-the-docker-image","text":"Type the below commands to build the Docker image: 1 2 3 IMAGE_NAME = \"capsule-hello-demo\" IMAGE_TAG = \"0.0.0\" docker build -t ${ IMAGE_NAME } . Test it Run the below command: 1 docker run -p 8080 :8080 -it ${ IMAGE_NAME } Then call the function: 1 2 3 curl -X POST http://localhost:8080 \\ -H 'content-type: application/json' \\ -d '{\"name\": \"Bob\"}' You should get: {\"message\":\"\ud83d\udc4b hello Bob\"}","title":"Build the Docker image"},{"location":"cookbook-fly/#push-the-docker-image-to-the-docker-hub","text":"Type the below commands to publish the Docker image: 1 2 3 4 5 IMAGE_NAME = \"capsule-hello-demo\" IMAGE_TAG = \"0.0.0\" docker login -u ${ DOCKER_USER } -p ${ DOCKER_PWD } docker tag ${ IMAGE_NAME } ${ DOCKER_USER } / ${ IMAGE_NAME } : ${ IMAGE_TAG } docker push ${ DOCKER_USER } / ${ IMAGE_NAME } : ${ IMAGE_TAG }","title":"Push the Docker image to the Docker Hub"},{"location":"cookbook-fly/#deploy-the-function-on-flyio","text":"Before the first deployment, you need to create the application on Fly.io : 1 2 3 # Create the application, only at the first deployment APPLICATION_NAME = \"capsule-hello-demo\" flyctl apps create ${ APPLICATION_NAME } --json And then, run the below commands to deploy the function: 1 2 3 4 5 6 7 8 IMAGE_NAME = \"capsule-hello-demo\" IMAGE_TAG = \"0.0.0\" APPLICATION_NAME = \"capsule-hello-demo\" flyctl deploy \\ --app ${ APPLICATION_NAME } \\ --image ${ DOCKER_USER } / ${ IMAGE_NAME } : ${ IMAGE_TAG } \\ --verbose --json Output : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 == > Verifying app config --> Verified app config == > Building image Searching for image 'k33g/capsule-hello-demo:0.0.3' remotely... image found: img_ox20prmgxx3vj1zq == > Creating release --> release v2 created --> You can detach the terminal anytime without stopping the deployment == > Monitoring deployment 1 desired, 1 placed, 0 healthy, 0 unhealthy [ health checks: 1 total, 1 pa 1 desired, 1 placed, 1 healthy, 0 unhealthy [ health checks: 1 total, 1 pa 1 desired, 1 placed, 1 healthy, 0 unhealthy [ health checks: 1 total, 1 passing ] --> v0 deployed successfully The function is deployed \ud83c\udf89","title":"\ud83d\ude80 Deploy the function on Fly.io"},{"location":"cookbook-fly/#test-the-function","text":"Run the below commands: 1 2 3 4 5 6 7 APPLICATION_NAME = \"capsule-hello-demo\" # The function url follows the following form: URL = \"https:// ${ {APPLICATION_NAME } }.fly.dev\" curl -X POST ${ URL } \\ -H 'content-type: application/json' \\ -d '{\"name\": \"Bob\"}' You should get: {\"message\":\"\ud83d\udc4b hello Bob\"} \ud83c\udf89 Fly.io is an excellent option for deploying a container with ease.","title":"Test the function"},{"location":"first-cli-function/","text":"Developer Guide First CLI function Create a go.mod file: ( go mod init cli-say-hello ) 1 2 3 module cli-say-hello go 1.18 Install the Capsule dependencies: 1 go get github.com/bots-garden/capsule/capsulemodule/hostfunctions Create a hello.go file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main () { hf . SetHandle ( Handle ) } func Handle ( params [] string ) ( string , error ) { var err error for _ , param := range params { hf . Log ( \"- parameter is: \" + param ) } ret := \"The first parameter is: \" + params [ 0 ] return ret , err // err = nil } hf.SetHandle(Handle) defines the called wasm function hf.Log(string) prints a value Build the wasm module: 1 tinygo build -o hello.wasm -scheduler = none --no-debug -target wasi ./hello.go Execute the Handle function: 1 2 3 4 ./capsule \\ -wasm = ./hello.wasm \\ -mode = cli \\ \"\ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83\" 1234 \"Bob Morane\" -wasm flag: the path to the wasm file -mode execution mode output: 1 2 3 4 - parameter is: \ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83 - parameter is: 1234 - parameter is: Bob Morane The first parameter is: \ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83","title":"First CLI function"},{"location":"first-cli-function/#developer-guide","text":"","title":"Developer Guide"},{"location":"first-cli-function/#first-cli-function","text":"Create a go.mod file: ( go mod init cli-say-hello ) 1 2 3 module cli-say-hello go 1.18 Install the Capsule dependencies: 1 go get github.com/bots-garden/capsule/capsulemodule/hostfunctions Create a hello.go file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main () { hf . SetHandle ( Handle ) } func Handle ( params [] string ) ( string , error ) { var err error for _ , param := range params { hf . Log ( \"- parameter is: \" + param ) } ret := \"The first parameter is: \" + params [ 0 ] return ret , err // err = nil } hf.SetHandle(Handle) defines the called wasm function hf.Log(string) prints a value Build the wasm module: 1 tinygo build -o hello.wasm -scheduler = none --no-debug -target wasi ./hello.go Execute the Handle function: 1 2 3 4 ./capsule \\ -wasm = ./hello.wasm \\ -mode = cli \\ \"\ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83\" 1234 \"Bob Morane\" -wasm flag: the path to the wasm file -mode execution mode output: 1 2 3 4 - parameter is: \ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83 - parameter is: 1234 - parameter is: Bob Morane The first parameter is: \ud83d\udc4b hello world \ud83c\udf0d\ud83c\udf83","title":"First CLI function"},{"location":"first-http-function/","text":"Developer Guide First HTTP function Create a go.mod file: ( go mod init http-say-hello ) 1 2 3 module http-say-hello go 1.18 To serve the function through http, you need to change the signature of the Handle function: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main () { hf . SetHandleHttp ( Handle ) } func Handle ( request hf . Request ) ( response hf . Response , errResp error ) { hf . Log ( \"\ud83d\udcdd Body: \" + request . Body ) // Read the request headers hf . Log ( \"Content-Type: \" + request . Headers [ \"Content-Type\" ]) hf . Log ( \"Content-Length: \" + request . Headers [ \"Content-Length\" ]) hf . Log ( \"User-Agent: \" + request . Headers [ \"User-Agent\" ]) // Read the MESSAGE environment variable envMessage , err := hf . GetEnv ( \"MESSAGE\" ) if err != nil { hf . Log ( \"\ud83d\ude21 \" + err . Error ()) } else { hf . Log ( \"Environment variable: \" + envMessage ) } // Set the response content type and add a message header headersResp := map [ string ] string { \"Content-Type\" : \"application/json; charset=utf-8\" , \"Message\" : \"\ud83d\udc4b hello world \ud83c\udf0d\" , } jsonResponse := `{\"message\": \"hey people!\"}` return hf . Response { Body : jsonResponse , Headers : headersResp }, err } hf.SetHandleHttp(Handle) defines the called wasm function hf.Log(string) prints a value hf.GetEnv(\"MESSAGE\") get the value of the MESSAGE environment variable Build the wasm module: 1 tinygo build -o hello.wasm -scheduler = none --no-debug -target wasi ./hello.go Serve the Handle function: 1 2 3 4 5 export MESSAGE = \"\ud83d\udd90 good morning \ud83d\ude04\" ./capsule \\ -wasm = ./hello.wasm \\ -mode = http \\ -httpPort = 8080 Call the Handle function: 1 2 3 4 curl -v -X POST \\ http://localhost:8080 \\ -H 'content-type: application/json; charset=utf-8' \\ -d '{\"message\": \"TinyGo \ud83d\udc9a wasm\"}' request output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 > POST / HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.79.1 > Accept: */* > content-type: application/json ; charset = utf-8 > Content-Length: 31 > * Mark bundle as not supporting multiuse < HTTP/1.1 200 OK < Content-Type: application/json ; charset = utf-8 < Message: \ud83d\udc4b hello world \ud83c\udf0d < Date: Sat, 30 Jul 2022 19 :17:28 GMT < Content-Length: 26 < { \"message\" : \"hey people!\" } log server output: 1 2 3 4 5 \ud83d\udcdd body: { \"message\" : \"TinyGo \ud83d\udc9a wasm\" } Content-Type: application/json ; charset = utf-8 Content-Length: 31 User-Agent: curl/7.79.1 Environment variable: \ud83d\udd90 good morning \ud83d\ude04 OnLoad function If you add an OnLoad exported function to the module, it will be executed at the start of the HTTP launcher (capsule). the main function will be executed too 1 2 3 4 //export OnLoad func OnLoad () { hf . Log ( \"\ud83d\udc4b from the OnLoad function\" ) } It can be useful to register your wasm service to a backend (Redis, CouchBase, ...) OnExit function If you add an OnExit exported function to the module, it will be executed when you stop the HTTP launcher (capsule). the main function will be executed too 1 2 3 4 //export OnExit func OnExit () { hf . Log ( \"\ud83d\udc4b from the OnExit function\" ) } It can be useful to unregister your wasm service from a backend (Redis, CouchBase, ...) GetExitError and GetExitCode function \ud83d\udd90\ud83d\udea7 it's a work in progress (it's not implemented entirely) 1 2 3 4 5 6 //export OnExit func OnExit () { hf . Log ( \"\ud83d\udc4b\ud83e\udd17 have a nice day\" ) hf . Log ( \"Exit Error: \" + hf . GetExitError ()) hf . Log ( \"Exit Code: \" + hf . GetExitCode ()) } Remote loading of the wasm module You can download the wasm module from a remote location before executing it: For example, provide the wasm file with an HTTP server, run this command at the root of your project: 1 python3 -m http.server 9090 Now you can download the wasm file with this url: http://localhost:9090/hello.wasm Serve the Handle function: 1 2 3 4 5 6 export MESSAGE = \"\ud83d\udd90 good morning \ud83d\ude04\" ./capsule \\ -url = http://localhost:9090/hello.wasm \\ -wasm = ./tmp/hello.wasm \\ -mode = http \\ -httpPort = 8080 -url flag: the download url -wasm flag: the path where to save the wasm file GET Request Capsule accept the GET requests, so you can serve, for example, HTML: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main () { hf . SetHandleHttp ( Handle ) } func Handle ( request hf . Request ) ( response hf . Response , errResp error ) { html := ` <html> <head> <title>Wasm is fantastic \ud83d\ude0d</title> </head> <body> <h1>\ud83d\udc4b Hello World \ud83c\udf0d</h1> <h2>Served with \ud83d\udc9c with Capsule \ud83d\udc8a</h2> </body> </html> ` headersResp := map [ string ] string { \"Content-Type\" : \"text/html; charset=utf-8\" , } return hf . Response { Body : html , Headers : headersResp }, nil } Build the wasm module: 1 tinygo build -o hello.wasm -scheduler = none --no-debug -target wasi ./hello.go Serve the Handle \"function page\": 1 2 3 4 ./capsule \\ -wasm = ./hello.wasm \\ -mode = http \\ -httpPort = 8080 Now, you can open http://localhost:8080 with your browser or run a curl request: 1 curl http://localhost:8080","title":"First HTTP function"},{"location":"first-http-function/#developer-guide","text":"","title":"Developer Guide"},{"location":"first-http-function/#first-http-function","text":"Create a go.mod file: ( go mod init http-say-hello ) 1 2 3 module http-say-hello go 1.18 To serve the function through http, you need to change the signature of the Handle function: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main () { hf . SetHandleHttp ( Handle ) } func Handle ( request hf . Request ) ( response hf . Response , errResp error ) { hf . Log ( \"\ud83d\udcdd Body: \" + request . Body ) // Read the request headers hf . Log ( \"Content-Type: \" + request . Headers [ \"Content-Type\" ]) hf . Log ( \"Content-Length: \" + request . Headers [ \"Content-Length\" ]) hf . Log ( \"User-Agent: \" + request . Headers [ \"User-Agent\" ]) // Read the MESSAGE environment variable envMessage , err := hf . GetEnv ( \"MESSAGE\" ) if err != nil { hf . Log ( \"\ud83d\ude21 \" + err . Error ()) } else { hf . Log ( \"Environment variable: \" + envMessage ) } // Set the response content type and add a message header headersResp := map [ string ] string { \"Content-Type\" : \"application/json; charset=utf-8\" , \"Message\" : \"\ud83d\udc4b hello world \ud83c\udf0d\" , } jsonResponse := `{\"message\": \"hey people!\"}` return hf . Response { Body : jsonResponse , Headers : headersResp }, err } hf.SetHandleHttp(Handle) defines the called wasm function hf.Log(string) prints a value hf.GetEnv(\"MESSAGE\") get the value of the MESSAGE environment variable Build the wasm module: 1 tinygo build -o hello.wasm -scheduler = none --no-debug -target wasi ./hello.go Serve the Handle function: 1 2 3 4 5 export MESSAGE = \"\ud83d\udd90 good morning \ud83d\ude04\" ./capsule \\ -wasm = ./hello.wasm \\ -mode = http \\ -httpPort = 8080 Call the Handle function: 1 2 3 4 curl -v -X POST \\ http://localhost:8080 \\ -H 'content-type: application/json; charset=utf-8' \\ -d '{\"message\": \"TinyGo \ud83d\udc9a wasm\"}' request output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 > POST / HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.79.1 > Accept: */* > content-type: application/json ; charset = utf-8 > Content-Length: 31 > * Mark bundle as not supporting multiuse < HTTP/1.1 200 OK < Content-Type: application/json ; charset = utf-8 < Message: \ud83d\udc4b hello world \ud83c\udf0d < Date: Sat, 30 Jul 2022 19 :17:28 GMT < Content-Length: 26 < { \"message\" : \"hey people!\" } log server output: 1 2 3 4 5 \ud83d\udcdd body: { \"message\" : \"TinyGo \ud83d\udc9a wasm\" } Content-Type: application/json ; charset = utf-8 Content-Length: 31 User-Agent: curl/7.79.1 Environment variable: \ud83d\udd90 good morning \ud83d\ude04","title":"First HTTP function"},{"location":"first-http-function/#onload-function","text":"If you add an OnLoad exported function to the module, it will be executed at the start of the HTTP launcher (capsule). the main function will be executed too 1 2 3 4 //export OnLoad func OnLoad () { hf . Log ( \"\ud83d\udc4b from the OnLoad function\" ) } It can be useful to register your wasm service to a backend (Redis, CouchBase, ...)","title":"OnLoad function"},{"location":"first-http-function/#onexit-function","text":"If you add an OnExit exported function to the module, it will be executed when you stop the HTTP launcher (capsule). the main function will be executed too 1 2 3 4 //export OnExit func OnExit () { hf . Log ( \"\ud83d\udc4b from the OnExit function\" ) } It can be useful to unregister your wasm service from a backend (Redis, CouchBase, ...)","title":"OnExit function"},{"location":"first-http-function/#getexiterror-and-getexitcode-function","text":"\ud83d\udd90\ud83d\udea7 it's a work in progress (it's not implemented entirely) 1 2 3 4 5 6 //export OnExit func OnExit () { hf . Log ( \"\ud83d\udc4b\ud83e\udd17 have a nice day\" ) hf . Log ( \"Exit Error: \" + hf . GetExitError ()) hf . Log ( \"Exit Code: \" + hf . GetExitCode ()) }","title":"GetExitError and GetExitCode function"},{"location":"first-http-function/#remote-loading-of-the-wasm-module","text":"You can download the wasm module from a remote location before executing it: For example, provide the wasm file with an HTTP server, run this command at the root of your project: 1 python3 -m http.server 9090 Now you can download the wasm file with this url: http://localhost:9090/hello.wasm Serve the Handle function: 1 2 3 4 5 6 export MESSAGE = \"\ud83d\udd90 good morning \ud83d\ude04\" ./capsule \\ -url = http://localhost:9090/hello.wasm \\ -wasm = ./tmp/hello.wasm \\ -mode = http \\ -httpPort = 8080 -url flag: the download url -wasm flag: the path where to save the wasm file","title":"Remote loading of the wasm module"},{"location":"first-http-function/#get-request","text":"Capsule accept the GET requests, so you can serve, for example, HTML: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package main import hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" // main is required. func main () { hf . SetHandleHttp ( Handle ) } func Handle ( request hf . Request ) ( response hf . Response , errResp error ) { html := ` <html> <head> <title>Wasm is fantastic \ud83d\ude0d</title> </head> <body> <h1>\ud83d\udc4b Hello World \ud83c\udf0d</h1> <h2>Served with \ud83d\udc9c with Capsule \ud83d\udc8a</h2> </body> </html> ` headersResp := map [ string ] string { \"Content-Type\" : \"text/html; charset=utf-8\" , } return hf . Response { Body : html , Headers : headersResp }, nil } Build the wasm module: 1 tinygo build -o hello.wasm -scheduler = none --no-debug -target wasi ./hello.go Serve the Handle \"function page\": 1 2 3 4 ./capsule \\ -wasm = ./hello.wasm \\ -mode = http \\ -httpPort = 8080 Now, you can open http://localhost:8080 with your browser or run a curl request: 1 curl http://localhost:8080","title":"GET Request"},{"location":"first-mqtt-function/","text":"Developer Guide First MQTT function \ud83d\udd90\ud83d\udea7 The MQTT integration with Capsule is a work in progress and the functions are subject to change MQTT is a standard for IOT message. About MQTT: https://mqtt.org/ Requirements MQTT Server You need to install and run a MQTT server. To do so, go to the ./mqtt directory of this project and run the docker-compose file Run Capsule as a MQTT subscriber: 1 2 3 4 5 6 capsule \\ -wasm = ../wasm_modules/capsule-mqtt-subscriber/hello.wasm \\ -mode = mqtt \\ -mqttsrv = 127 .0.0.1:1883 \\ -topic = topic/sensor0 \\ -clientId = sensor use the \"MQTT mode\": -mode=mqtt define the MQTT topic: -topic=<topic_name> define the MQTT clientId: -clientId=<clientId> define the address of the MQTT server: -mqttsrv=<mqtt_server:port> MQTT function A Capsule MQTT function is a subscription to a subject. Capsule is listening on a topic and execute a function every time a message is posted on the subject: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . OnMqttMessage ( Handle ) // define the triggered function when a message \"arrives\" on the topic } // at every message on the subject channel, the `Handle` function is executed func Handle ( params [] string ) { // send a message to another subject _ , err := hf . MqttPublish ( \"topic/reply\" , \"it's a wasm module here\" ) if err != nil { hf . Log ( \"\ud83d\ude21 ouch something bad is happening\" ) hf . Log ( err . Error ()) } } Capsule MQTT publisher Publish MQTT messages from capsule You can use a WASM Capsule module to MQTT messages, even if Capsule is not started in \"mqtt\" mode, for example from a WASM CLI Capsule module : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main () { hf . SetHandle ( Handle ) } func Handle ( params [] string ) ( string , error ) { var errs [] string // a new connection is created at every call/publish _ , err1stMsg := hf . MqttConnectPublish ( \"127.0.0.1:1883\" , \"sensor\" , \"topic/sensor1\" , \"\ud83d\udd90 Hello from WASM with MQTT \ud83d\udc9c\" ) _ , err2ndMsg := hf . MqttConnectPublish ( \"127.0.0.1:1883\" , \"sensor\" , \"topic/sensor2\" , \"\ud83d\udc4b Hello World \ud83c\udf0d\" ) if err1stMsg != nil { errs = append ( errs , err1stMsg . Error ()) } if err2ndMsg != nil { errs = append ( errs , err2ndMsg . Error ()) } return \"MQTT Rocks!\" , errors . New ( strings . Join ( errs , \"|\" )) } In this use case, you need to define the MQTT server and create a connection","title":"First MQTT function"},{"location":"first-mqtt-function/#developer-guide","text":"","title":"Developer Guide"},{"location":"first-mqtt-function/#first-mqtt-function","text":"\ud83d\udd90\ud83d\udea7 The MQTT integration with Capsule is a work in progress and the functions are subject to change MQTT is a standard for IOT message. About MQTT: https://mqtt.org/","title":"First MQTT function"},{"location":"first-mqtt-function/#requirements","text":"","title":"Requirements"},{"location":"first-mqtt-function/#mqtt-server","text":"You need to install and run a MQTT server. To do so, go to the ./mqtt directory of this project and run the docker-compose file","title":"MQTT Server"},{"location":"first-mqtt-function/#run-capsule-as-a-mqtt-subscriber","text":"1 2 3 4 5 6 capsule \\ -wasm = ../wasm_modules/capsule-mqtt-subscriber/hello.wasm \\ -mode = mqtt \\ -mqttsrv = 127 .0.0.1:1883 \\ -topic = topic/sensor0 \\ -clientId = sensor use the \"MQTT mode\": -mode=mqtt define the MQTT topic: -topic=<topic_name> define the MQTT clientId: -clientId=<clientId> define the address of the MQTT server: -mqttsrv=<mqtt_server:port>","title":"Run Capsule as a MQTT subscriber:"},{"location":"first-mqtt-function/#mqtt-function","text":"A Capsule MQTT function is a subscription to a subject. Capsule is listening on a topic and execute a function every time a message is posted on the subject: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . OnMqttMessage ( Handle ) // define the triggered function when a message \"arrives\" on the topic } // at every message on the subject channel, the `Handle` function is executed func Handle ( params [] string ) { // send a message to another subject _ , err := hf . MqttPublish ( \"topic/reply\" , \"it's a wasm module here\" ) if err != nil { hf . Log ( \"\ud83d\ude21 ouch something bad is happening\" ) hf . Log ( err . Error ()) } }","title":"MQTT function"},{"location":"first-mqtt-function/#capsule-mqtt-publisher","text":"Publish MQTT messages from capsule You can use a WASM Capsule module to MQTT messages, even if Capsule is not started in \"mqtt\" mode, for example from a WASM CLI Capsule module : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main () { hf . SetHandle ( Handle ) } func Handle ( params [] string ) ( string , error ) { var errs [] string // a new connection is created at every call/publish _ , err1stMsg := hf . MqttConnectPublish ( \"127.0.0.1:1883\" , \"sensor\" , \"topic/sensor1\" , \"\ud83d\udd90 Hello from WASM with MQTT \ud83d\udc9c\" ) _ , err2ndMsg := hf . MqttConnectPublish ( \"127.0.0.1:1883\" , \"sensor\" , \"topic/sensor2\" , \"\ud83d\udc4b Hello World \ud83c\udf0d\" ) if err1stMsg != nil { errs = append ( errs , err1stMsg . Error ()) } if err2ndMsg != nil { errs = append ( errs , err2ndMsg . Error ()) } return \"MQTT Rocks!\" , errors . New ( strings . Join ( errs , \"|\" )) } In this use case, you need to define the MQTT server and create a connection","title":"Capsule MQTT publisher"},{"location":"first-nats-function/","text":"Developer Guide First Nats function \ud83d\udd90\ud83d\udea7 The NAT integration with Capsule is a work in progress and the functions are subject to change NATS is an open-source messaging system. About NATS: https://nats.io/ and https://docs.nats.io/ Nats Overview: https://docs.nats.io/nats-concepts/overview Requirements NATS Server You need to install and run a NATS server: https://docs.nats.io/running-a-nats-service/introduction/installation. Otherwise, I created a Virtual Machine for this; If you have installed Multipass , go to the ./nats/vm-nats directory of this project. I created some scripts for my experiments: create-vm.sh create the multipass VM, the settings of the VM are stored in the vm.nats.config 01-install-nats-server.sh install the NATS server inside the VM 02-start-nats-server.sh start the NATS server 03-stop-nats-server.sh stop the NATS server stop-vm.sh stop the VM start-vm.sh start the VM destroy-vm.sh delete the VM shell-vm.sh SSH connect to the VM NATS Client You need a NATS client to publish messages. You can find sample of Go and Node.js NATS clients in the ./nats/clients . Run Capsule as a NATS subscriber: 1 2 3 4 5 capsule \\ -wasm = ../wasm_modules/capsule-nats-subscriber/hello.wasm \\ -mode = nats \\ -natssrv = nats.devsecops.fun:4222 \\ -subject = ping use the \"NATS mode\": -mode=nats define the NATS subject: -subject=<subject_name> define the address of the NATS server: -natssrv=<nats_server:port> NATS function A Capsule NATS function is a subscription to a subject. Capsule is listening on a subject(like a MQTT topic) and execute a function every time a message is posted on the subject: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . OnNatsMessage ( Handle ) // define the triggered function when a message \"arrives\" on the subject/topic } // at every message on the subject channel, the `Handle` function is executed func Handle ( params [] string ) { // send a message to another subject _ , err := hf . NatsPublish ( \"notify\" , \"it's a wasm module here\" ) if err != nil { hf . Log ( \"\ud83d\ude21 ouch something bad is happening\" ) hf . Log ( err . Error ()) } } Capsule NATS publisher Publish NATS messages from capsule You can use a WASM Capsule module to publish NATS messages, even if Capsule is not started in \"nats\" mode, for example from a WASM CLI Capsule module : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main () { hf . SetHandle ( Handle ) } func Handle ( params [] string ) ( string , error ) { var errs [] string // a new connection is created at every call/publish _ , err1stMsg := hf . NatsConnectPublish ( \"nats.devsecops.fun:4222\" , \"ping\" , \"\ud83d\udd90 Hello from WASM with Nats \ud83d\udc9c\" ) _ , err2ndMsg := hf . NatsConnectPublish ( \"nats.devsecops.fun:4222\" , \"notify\" , \"\ud83d\udc4b Hello World \ud83c\udf0d\" ) if err1stMsg != nil { errs = append ( errs , err1stMsg . Error ()) } if err2ndMsg != nil { errs = append ( errs , err2ndMsg . Error ()) } return \"NATS Rocks!\" , errors . New ( strings . Join ( errs , \"|\" )) } In this use case, you need to define the NATS server and create a connection Request and Reply A NATS \"publisher\" can make a request to a NATS \"subscriber\" and wait for an answer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main () { hf . SetHandle ( Handle ) } func Handle ( params [] string ) ( string , error ) { // Publish and wait for an answer; 1 is the timeout in seconds res , err := hf . NatsConnectRequest ( \"nats.devsecops.fun:4222\" , \"notify\" , \"\ud83d\udc4b Hello World \ud83c\udf0d\" , 1 ) if err != nil { hf . Log ( \"\ud83d\udd34\" + err . Error ()) } else { // Display the answer hf . Log ( \"\ud83d\udd35\" + res ) } return \"NATS Rocks!\" , err } A NATS \"subscriber\" can reply to a request received on its subject 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . OnNatsMessage ( Handle ) } func Handle ( params [] string ) { hf . Log ( \"Message on subject: \" + hf . NatsGetSubject () + \", \ud83c\udf89 message: \" + params [ 0 ]) // reply to the message on the current subject; 10 is the timeout in seconds _ , _ = hf . NatsReply ( \"Hey! What's up\" , 10 ) }","title":"First Nats function"},{"location":"first-nats-function/#developer-guide","text":"","title":"Developer Guide"},{"location":"first-nats-function/#first-nats-function","text":"\ud83d\udd90\ud83d\udea7 The NAT integration with Capsule is a work in progress and the functions are subject to change NATS is an open-source messaging system. About NATS: https://nats.io/ and https://docs.nats.io/ Nats Overview: https://docs.nats.io/nats-concepts/overview","title":"First Nats function"},{"location":"first-nats-function/#requirements","text":"","title":"Requirements"},{"location":"first-nats-function/#nats-server","text":"You need to install and run a NATS server: https://docs.nats.io/running-a-nats-service/introduction/installation. Otherwise, I created a Virtual Machine for this; If you have installed Multipass , go to the ./nats/vm-nats directory of this project. I created some scripts for my experiments: create-vm.sh create the multipass VM, the settings of the VM are stored in the vm.nats.config 01-install-nats-server.sh install the NATS server inside the VM 02-start-nats-server.sh start the NATS server 03-stop-nats-server.sh stop the NATS server stop-vm.sh stop the VM start-vm.sh start the VM destroy-vm.sh delete the VM shell-vm.sh SSH connect to the VM","title":"NATS Server"},{"location":"first-nats-function/#nats-client","text":"You need a NATS client to publish messages. You can find sample of Go and Node.js NATS clients in the ./nats/clients .","title":"NATS Client"},{"location":"first-nats-function/#run-capsule-as-a-nats-subscriber","text":"1 2 3 4 5 capsule \\ -wasm = ../wasm_modules/capsule-nats-subscriber/hello.wasm \\ -mode = nats \\ -natssrv = nats.devsecops.fun:4222 \\ -subject = ping use the \"NATS mode\": -mode=nats define the NATS subject: -subject=<subject_name> define the address of the NATS server: -natssrv=<nats_server:port>","title":"Run Capsule as a NATS subscriber:"},{"location":"first-nats-function/#nats-function","text":"A Capsule NATS function is a subscription to a subject. Capsule is listening on a subject(like a MQTT topic) and execute a function every time a message is posted on the subject: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . OnNatsMessage ( Handle ) // define the triggered function when a message \"arrives\" on the subject/topic } // at every message on the subject channel, the `Handle` function is executed func Handle ( params [] string ) { // send a message to another subject _ , err := hf . NatsPublish ( \"notify\" , \"it's a wasm module here\" ) if err != nil { hf . Log ( \"\ud83d\ude21 ouch something bad is happening\" ) hf . Log ( err . Error ()) } }","title":"NATS function"},{"location":"first-nats-function/#capsule-nats-publisher","text":"Publish NATS messages from capsule You can use a WASM Capsule module to publish NATS messages, even if Capsule is not started in \"nats\" mode, for example from a WASM CLI Capsule module : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main () { hf . SetHandle ( Handle ) } func Handle ( params [] string ) ( string , error ) { var errs [] string // a new connection is created at every call/publish _ , err1stMsg := hf . NatsConnectPublish ( \"nats.devsecops.fun:4222\" , \"ping\" , \"\ud83d\udd90 Hello from WASM with Nats \ud83d\udc9c\" ) _ , err2ndMsg := hf . NatsConnectPublish ( \"nats.devsecops.fun:4222\" , \"notify\" , \"\ud83d\udc4b Hello World \ud83c\udf0d\" ) if err1stMsg != nil { errs = append ( errs , err1stMsg . Error ()) } if err2ndMsg != nil { errs = append ( errs , err2ndMsg . Error ()) } return \"NATS Rocks!\" , errors . New ( strings . Join ( errs , \"|\" )) } In this use case, you need to define the NATS server and create a connection","title":"Capsule NATS publisher"},{"location":"first-nats-function/#request-and-reply","text":"A NATS \"publisher\" can make a request to a NATS \"subscriber\" and wait for an answer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import ( \"errors\" hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" \"strings\" ) func main () { hf . SetHandle ( Handle ) } func Handle ( params [] string ) ( string , error ) { // Publish and wait for an answer; 1 is the timeout in seconds res , err := hf . NatsConnectRequest ( \"nats.devsecops.fun:4222\" , \"notify\" , \"\ud83d\udc4b Hello World \ud83c\udf0d\" , 1 ) if err != nil { hf . Log ( \"\ud83d\udd34\" + err . Error ()) } else { // Display the answer hf . Log ( \"\ud83d\udd35\" + res ) } return \"NATS Rocks!\" , err } A NATS \"subscriber\" can reply to a request received on its subject 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . OnNatsMessage ( Handle ) } func Handle ( params [] string ) { hf . Log ( \"Message on subject: \" + hf . NatsGetSubject () + \", \ud83c\udf89 message: \" + params [ 0 ]) // reply to the message on the current subject; 10 is the timeout in seconds _ , _ = hf . NatsReply ( \"Hey! What's up\" , 10 ) }","title":"Request and Reply"},{"location":"getting-started-cabu-build/","text":"\ud83d\ude80 Getting Started Build the hello-world function with Cabu For building the WASM function, use the cabu build command: 1 2 cd hello-world cabu build . hello-world.go hello-world.wasm Build the hello-world function with TinyGo You can build the wasm module without Cabu . But you need to install Go and TinyGo : 1 2 3 cd hello-world go mod tidy tinygo build -o hello-world.wasm -scheduler = none -target wasi ./hello-world.go","title":"Build the function module"},{"location":"getting-started-cabu-build/#getting-started","text":"","title":"\ud83d\ude80 Getting Started"},{"location":"getting-started-cabu-build/#build-the-hello-world-function-with-cabu","text":"For building the WASM function, use the cabu build command: 1 2 cd hello-world cabu build . hello-world.go hello-world.wasm","title":"Build the hello-world function with Cabu"},{"location":"getting-started-cabu-build/#build-the-hello-world-function-with-tinygo","text":"You can build the wasm module without Cabu . But you need to install Go and TinyGo : 1 2 3 cd hello-world go mod tidy tinygo build -o hello-world.wasm -scheduler = none -target wasi ./hello-world.go","title":"Build the hello-world function with TinyGo"},{"location":"getting-started-cabu-gen/","text":"\ud83d\ude80 Getting Started Generate a new project function Cabu can generate function project from templates: 1 2 3 # template name: `service-get` # function project name `hello-world` cabu generate service-get hello-world At the first launch, Cabu will pull a docker image with all the necessary resources to build the WASM function. 1 2 3 4 5 6 7 8 9 \ud83d\udc33 using k33g/capsule-builder:0.0.2 Unable to find image 'k33g/capsule-builder:0.0.2' locally 0 .0.2: Pulling from k33g/capsule-builder 68c15fb212c3: Pull complete 28b965d0936e: Pull complete f7ba6ae51b0b: Pull complete Digest: sha256:47ebf274d7c378d1795f6c8a78d71c45e8368b33a7a3ba8e48ef131a08fd9ac4 Status: Downloaded newer image for k33g/capsule-builder:0.0.2 \u2705\ud83d\ude42 hello-world function generated Cabu has generated the hello-world project: 1 2 3 4 . \u251c\u2500\u2500 hello-world \u2502 \u251c\u2500\u2500 go.mod \u2502 \u2514\u2500\u2500 hello-world.go With the following source code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . SetHandleHttp ( Handle ) } func Handle ( req hf . Request ) ( resp hf . Response , errResp error ) { headers := map [ string ] string { \"Content-Type\" : \"text/html; charset=utf-8\" , } resp = hf . Response { Body : \"<h1>\ud83d\udc4b hello world \ud83c\udf0d</h1>\" , Headers : headers , } return resp , nil }","title":"Generate a function"},{"location":"getting-started-cabu-gen/#getting-started","text":"","title":"\ud83d\ude80 Getting Started"},{"location":"getting-started-cabu-gen/#generate-a-new-project-function","text":"Cabu can generate function project from templates: 1 2 3 # template name: `service-get` # function project name `hello-world` cabu generate service-get hello-world At the first launch, Cabu will pull a docker image with all the necessary resources to build the WASM function. 1 2 3 4 5 6 7 8 9 \ud83d\udc33 using k33g/capsule-builder:0.0.2 Unable to find image 'k33g/capsule-builder:0.0.2' locally 0 .0.2: Pulling from k33g/capsule-builder 68c15fb212c3: Pull complete 28b965d0936e: Pull complete f7ba6ae51b0b: Pull complete Digest: sha256:47ebf274d7c378d1795f6c8a78d71c45e8368b33a7a3ba8e48ef131a08fd9ac4 Status: Downloaded newer image for k33g/capsule-builder:0.0.2 \u2705\ud83d\ude42 hello-world function generated Cabu has generated the hello-world project: 1 2 3 4 . \u251c\u2500\u2500 hello-world \u2502 \u251c\u2500\u2500 go.mod \u2502 \u2514\u2500\u2500 hello-world.go With the following source code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) func main () { hf . SetHandleHttp ( Handle ) } func Handle ( req hf . Request ) ( resp hf . Response , errResp error ) { headers := map [ string ] string { \"Content-Type\" : \"text/html; charset=utf-8\" , } resp = hf . Response { Body : \"<h1>\ud83d\udc4b hello world \ud83c\udf0d</h1>\" , Headers : headers , } return resp , nil }","title":"Generate a new project function"},{"location":"getting-started-cabu-inst/","text":"\ud83d\ude80 Getting Started The simplest way to create your first Capsule Function is to use Cabu To write and build wasm function for Capsule, you need to install GoLang and TinyGo. Otherwise, you can use the capsule-function-builder project. It provides a very simple CLI, named capsule-builder or cabu that uses a Docker image with all the necessary resources (Golang and TinyGo compilers). Install Cabu (Capsule Builder) 1 2 CAPSULE_BUILDER_VERSION = \"v0.0.3\" wget -O - https://raw.githubusercontent.com/bots-garden/capsule-function-builder/ ${ CAPSULE_BUILDER_VERSION } /install-capsule-builder.sh | bash","title":"Install the Cabu CLI"},{"location":"getting-started-cabu-inst/#getting-started","text":"The simplest way to create your first Capsule Function is to use Cabu To write and build wasm function for Capsule, you need to install GoLang and TinyGo. Otherwise, you can use the capsule-function-builder project. It provides a very simple CLI, named capsule-builder or cabu that uses a Docker image with all the necessary resources (Golang and TinyGo compilers).","title":"\ud83d\ude80 Getting Started"},{"location":"getting-started-cabu-inst/#install-cabu-capsule-builder","text":"1 2 CAPSULE_BUILDER_VERSION = \"v0.0.3\" wget -O - https://raw.githubusercontent.com/bots-garden/capsule-function-builder/ ${ CAPSULE_BUILDER_VERSION } /install-capsule-builder.sh | bash","title":"Install Cabu (Capsule Builder)"},{"location":"getting-started-cabu-reload/","text":"\ud83d\ude80 Getting Started Reload a deployed wasm module function Introduced in Capsule v0.2.9 \ud83e\udd9c [parrot] You can reload the running wasm module by using the /load-wasm-module route of Capsule , like this: 1 2 3 4 curl -v -X POST \\ http://localhost:7070/load-wasm-module \\ -H 'content-type: application/json; charset=utf-8' \\ -d '{\"url\": \"http://localhost:9090/hello-two/hello-two.wasm\", \"path\": \"./tmp/hello-two.wasm\"}' Protect /load-wasm-module with a token To protect the route, start capsule with the CAPSULE_RELOAD_TOKEN variable: 1 2 3 4 5 CAPSULE_RELOAD_TOKEN = \"ilovepandas\" capsule \\ -url = http://localhost:9090/hello-one/hello-one.wasm \\ -wasm = ./tmp/hello-one.wasm \\ -mode = http \\ -httpPort = 7070 Then, add the token to the headers of the request: 1 2 3 4 5 curl -v -X POST \\ http://localhost:7070/load-wasm-module \\ -H 'content-type: application/json; charset=utf-8' \\ -H 'CAPSULE_RELOAD_TOKEN: ilovepandas' \\ -d '{\"url\": \"http://localhost:9090/hello-two/hello-two.wasm\", \"path\": \"./tmp/hello-two.wasm\"}'","title":"Reload the module"},{"location":"getting-started-cabu-reload/#getting-started","text":"","title":"\ud83d\ude80 Getting Started"},{"location":"getting-started-cabu-reload/#reload-a-deployed-wasm-module-function","text":"Introduced in Capsule v0.2.9 \ud83e\udd9c [parrot] You can reload the running wasm module by using the /load-wasm-module route of Capsule , like this: 1 2 3 4 curl -v -X POST \\ http://localhost:7070/load-wasm-module \\ -H 'content-type: application/json; charset=utf-8' \\ -d '{\"url\": \"http://localhost:9090/hello-two/hello-two.wasm\", \"path\": \"./tmp/hello-two.wasm\"}'","title":"Reload a deployed wasm module function"},{"location":"getting-started-cabu-reload/#protect-load-wasm-module-with-a-token","text":"To protect the route, start capsule with the CAPSULE_RELOAD_TOKEN variable: 1 2 3 4 5 CAPSULE_RELOAD_TOKEN = \"ilovepandas\" capsule \\ -url = http://localhost:9090/hello-one/hello-one.wasm \\ -wasm = ./tmp/hello-one.wasm \\ -mode = http \\ -httpPort = 7070 Then, add the token to the headers of the request: 1 2 3 4 5 curl -v -X POST \\ http://localhost:7070/load-wasm-module \\ -H 'content-type: application/json; charset=utf-8' \\ -H 'CAPSULE_RELOAD_TOKEN: ilovepandas' \\ -d '{\"url\": \"http://localhost:9090/hello-two/hello-two.wasm\", \"path\": \"./tmp/hello-two.wasm\"}'","title":"Protect /load-wasm-module with a token"},{"location":"getting-started-cabu-serve-url/","text":"\ud83d\ude80 Getting Started Serve the module frome an url At start, Capsule can download the module function from an URL, store it to a directory of your choice, and then serve it. 1 2 3 4 5 capsule \\ -url = http://localhost:9090/hello-world/hello-world.wasm \\ -wasm = ./tmp/hello-world.wasm \\ -mode = http \\ -httpPort = 7070 You can provide a wasm module through HTTP with any HTTP server: 1 python3 -m http.server 9090 or you can use a wasm registry, like https://wapm.io/","title":"Serve the module frome an url"},{"location":"getting-started-cabu-serve-url/#getting-started","text":"","title":"\ud83d\ude80 Getting Started"},{"location":"getting-started-cabu-serve-url/#serve-the-module-frome-an-url","text":"At start, Capsule can download the module function from an URL, store it to a directory of your choice, and then serve it. 1 2 3 4 5 capsule \\ -url = http://localhost:9090/hello-world/hello-world.wasm \\ -wasm = ./tmp/hello-world.wasm \\ -mode = http \\ -httpPort = 7070 You can provide a wasm module through HTTP with any HTTP server: 1 python3 -m http.server 9090 or you can use a wasm registry, like https://wapm.io/","title":"Serve the module frome an url"},{"location":"getting-started-cabu-serve/","text":"\ud83d\ude80 Getting Started Serve the hello-world function Before serving the function, you need to install Capsule : see the install section Serve the function 1 2 3 4 capsule \\ -wasm = ./hello-world.wasm \\ -mode = http \\ -httpPort = 8080 Reach http://localhost:8080 with your browser Serve the function with the Capsule Docker image 1 2 3 4 5 6 7 docker run \\ -p 8080 :8080 \\ -v $( pwd ) :/app --rm k33g/capsule-launcher:0.2.9 \\ /capsule \\ -wasm = ./app/hello-world.wasm \\ -mode = http \\ -httpPort = 8080 The Capsule Docker image is an external project: https://github.com/bots-garden/capsule-docker-image","title":"Serve the function module"},{"location":"getting-started-cabu-serve/#getting-started","text":"","title":"\ud83d\ude80 Getting Started"},{"location":"getting-started-cabu-serve/#serve-the-hello-world-function","text":"Before serving the function, you need to install Capsule : see the install section","title":"Serve the hello-world function"},{"location":"getting-started-cabu-serve/#serve-the-function","text":"1 2 3 4 capsule \\ -wasm = ./hello-world.wasm \\ -mode = http \\ -httpPort = 8080 Reach http://localhost:8080 with your browser","title":"Serve the function"},{"location":"getting-started-cabu-serve/#serve-the-function-with-the-capsule-docker-image","text":"1 2 3 4 5 6 7 docker run \\ -p 8080 :8080 \\ -v $( pwd ) :/app --rm k33g/capsule-launcher:0.2.9 \\ /capsule \\ -wasm = ./app/hello-world.wasm \\ -mode = http \\ -httpPort = 8080 The Capsule Docker image is an external project: https://github.com/bots-garden/capsule-docker-image","title":"Serve the function with the Capsule Docker image"},{"location":"host-functions-couchbase/","text":"Host functions Make CouchBase N1QL Query You need to run Capsule with these four environment variables: 1 2 3 4 COUCHBASE_CLUSTER = \"couchbase://localhost\" COUCHBASE_USER = \"admin\" COUCHBASE_PWD = \"ilovepandas\" COUCHBASE_BUCKET = \"wasm-data\" 1 2 3 4 bucketName , _ := hf . GetEnv ( \"COUCHBASE_BUCKET\" ) query := \"SELECT * FROM `\" + bucketName + \"`.data.docs\" jsonStringArray , err := hf . CouchBaseQuery ( query )","title":"CouchBase"},{"location":"host-functions-couchbase/#host-functions","text":"","title":"Host functions"},{"location":"host-functions-couchbase/#make-couchbase-n1ql-query","text":"You need to run Capsule with these four environment variables: 1 2 3 4 COUCHBASE_CLUSTER = \"couchbase://localhost\" COUCHBASE_USER = \"admin\" COUCHBASE_PWD = \"ilovepandas\" COUCHBASE_BUCKET = \"wasm-data\" 1 2 3 4 bucketName , _ := hf . GetEnv ( \"COUCHBASE_BUCKET\" ) query := \"SELECT * FROM `\" + bucketName + \"`.data.docs\" jsonStringArray , err := hf . CouchBaseQuery ( query )","title":"Make CouchBase N1QL Query"},{"location":"host-functions-env/","text":"Host functions Read value of the environment variables 1 2 3 4 5 6 message , err := hf . GetEnv ( \"MESSAGE\" ) if err != nil { hf . Log ( err . Error ()) } else { hf . Log ( \"MESSAGE=\" + message ) }","title":"Environment"},{"location":"host-functions-env/#host-functions","text":"","title":"Host functions"},{"location":"host-functions-env/#read-value-of-the-environment-variables","text":"1 2 3 4 5 6 message , err := hf . GetEnv ( \"MESSAGE\" ) if err != nil { hf . Log ( err . Error ()) } else { hf . Log ( \"MESSAGE=\" + message ) }","title":"Read value of the environment variables"},{"location":"host-functions-errors/","text":"Host functions Error Management \ud83d\udd90\ud83d\udd90\ud83d\udd90 \ud83d\udea7 it's a work in progress (it's not implemented entirely) GetExitError() & GetExitCode : 1 2 3 4 5 6 //export OnExit func OnExit () { hf . Log ( \"\ud83d\udc4b\ud83e\udd17 have a nice day\" ) hf . Log ( \"Exit Error: \" + hf . GetExitError ()) hf . Log ( \"Exit Code: \" + hf . GetExitCode ()) }","title":"Errors"},{"location":"host-functions-errors/#host-functions","text":"","title":"Host functions"},{"location":"host-functions-errors/#error-management","text":"\ud83d\udd90\ud83d\udd90\ud83d\udd90 \ud83d\udea7 it's a work in progress (it's not implemented entirely) GetExitError() & GetExitCode : 1 2 3 4 5 6 //export OnExit func OnExit () { hf . Log ( \"\ud83d\udc4b\ud83e\udd17 have a nice day\" ) hf . Log ( \"Exit Error: \" + hf . GetExitError ()) hf . Log ( \"Exit Code: \" + hf . GetExitCode ()) }","title":"Error Management"},{"location":"host-functions-files/","text":"Host functions Read and Write files 1 2 3 4 5 6 7 8 9 10 11 txt , err := hf . ReadFile ( \"about.txt\" ) if err != nil { hf . Log ( err . Error ()) } hf . Log ( txt ) newFile , err := hf . WriteFile ( \"hello.txt\" , \"\ud83d\udc4b HELLO WORLD \ud83c\udf0d\" ) if err != nil { hf . Log ( err . Error ()) } hf . Log ( newFile )","title":"Files"},{"location":"host-functions-files/#host-functions","text":"","title":"Host functions"},{"location":"host-functions-files/#read-and-write-files","text":"1 2 3 4 5 6 7 8 9 10 11 txt , err := hf . ReadFile ( \"about.txt\" ) if err != nil { hf . Log ( err . Error ()) } hf . Log ( txt ) newFile , err := hf . WriteFile ( \"hello.txt\" , \"\ud83d\udc4b HELLO WORLD \ud83c\udf0d\" ) if err != nil { hf . Log ( err . Error ()) } hf . Log ( newFile )","title":"Read and Write files"},{"location":"host-functions-http/","text":"Host functions Make HTTP requests GET 1 2 3 4 5 6 ret , err := hf . Http ( \"https://httpbin.org/get\" , \"GET\" , headers , \"\" ) if err != nil { hf . Log ( \"\ud83d\ude21 error:\" + err . Error ()) } else { hf . Log ( \"\ud83d\udcddresult: \" + ret ) } POST 1 2 3 4 5 6 7 8 headers := map [ string ] string { \"Accept\" : \"application/json\" , \"Content-Type\" : \"text/html; charset=UTF-8\" } ret , err := hf . Http ( \"https://httpbin.org/post\" , \"POST\" , headers , \"\ud83d\udc4b hello world \ud83c\udf0d\" ) if err != nil { hf . Log ( \"\ud83d\ude21 error:\" + err . Error ()) } else { hf . Log ( \"\ud83d\udcddresult: \" + ret ) }","title":"HTTP Requests"},{"location":"host-functions-http/#host-functions","text":"","title":"Host functions"},{"location":"host-functions-http/#make-http-requests","text":"GET 1 2 3 4 5 6 ret , err := hf . Http ( \"https://httpbin.org/get\" , \"GET\" , headers , \"\" ) if err != nil { hf . Log ( \"\ud83d\ude21 error:\" + err . Error ()) } else { hf . Log ( \"\ud83d\udcddresult: \" + ret ) } POST 1 2 3 4 5 6 7 8 headers := map [ string ] string { \"Accept\" : \"application/json\" , \"Content-Type\" : \"text/html; charset=UTF-8\" } ret , err := hf . Http ( \"https://httpbin.org/post\" , \"POST\" , headers , \"\ud83d\udc4b hello world \ud83c\udf0d\" ) if err != nil { hf . Log ( \"\ud83d\ude21 error:\" + err . Error ()) } else { hf . Log ( \"\ud83d\udcddresult: \" + ret ) }","title":"Make HTTP requests"},{"location":"host-functions-intro/","text":"Host functions \ud83d\udea7 this is a work in progress, each host function will be detailed with samples in the coming weeks. Capsule offers some capabilities to the wasm modules by providing some \"host functions\":","title":"Introduction"},{"location":"host-functions-intro/#host-functions","text":"\ud83d\udea7 this is a work in progress, each host function will be detailed with samples in the coming weeks. Capsule offers some capabilities to the wasm modules by providing some \"host functions\":","title":"Host functions"},{"location":"host-functions-log/","text":"Host functions Print a message 1 hf . Log ( \"\ud83d\udc4b Hello World \ud83c\udf0d\" )","title":"Log"},{"location":"host-functions-log/#host-functions","text":"","title":"Host functions"},{"location":"host-functions-log/#print-a-message","text":"1 hf . Log ( \"\ud83d\udc4b Hello World \ud83c\udf0d\" )","title":"Print a message"},{"location":"host-functions-memory/","text":"Host functions Use memory cache MemorySet 1 _ , err := hf . MemorySet ( \"message\" , \"\ud83d\ude80 hello is started\" ) MemoryGet 1 value , err := hf . MemoryGet ( \"message\" ) MemoryKeys 1 2 3 4 5 6 7 8 9 keys , err := hf . MemoryKeys () // it will return an array of strings if err != nil { hf . Log ( err . Error ()) } for key , value := range keys { hf . Log ( key + \":\" + value ) }","title":"Memory cache"},{"location":"host-functions-memory/#host-functions","text":"","title":"Host functions"},{"location":"host-functions-memory/#use-memory-cache","text":"MemorySet 1 _ , err := hf . MemorySet ( \"message\" , \"\ud83d\ude80 hello is started\" ) MemoryGet 1 value , err := hf . MemoryGet ( \"message\" ) MemoryKeys 1 2 3 4 5 6 7 8 9 keys , err := hf . MemoryKeys () // it will return an array of strings if err != nil { hf . Log ( err . Error ()) } for key , value := range keys { hf . Log ( key + \":\" + value ) }","title":"Use memory cache"},{"location":"host-functions-mqtt/","text":"Host functions MQTT You must use the \"mqtt\" mode of Capsule as the MQTT connection is defined at the start of Capsule and shared with the WASM module: 1 2 3 4 5 6 capsule \\ -wasm = ../wasm_modules/capsule-mqtt-subscriber/hello.wasm \\ -mode = mqtt \\ -mqttsrv = 127 .0.0.1:1883 \\ -topic = topic/sensor0 \\ -clientId = sensor_id1 MQTT Handler as a Subscriber \ud83d\udd90 you have to call hf.OnMqttMessage(Handle) from the main function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) // the topic is defined when launching the capsule launcher func main () { hf . OnMqttMessage ( Handle ) } func Handle ( params [] string ) { message := params [ 0 ] hf . Log ( \"\ud83d\udc4b you get a message on topic \" + hf . MqttGetTopic () + \": \" + message ) // we use the connection of the launcher (capsule) _ , err := hf . MqttPublish ( \"topic/reply\" , \"it's a wasm module here\" ) if err != nil { hf . Log ( \"\ud83d\ude21 ouch something bad is happening\" ) hf . Log ( err . Error ()) } }","title":"MQTT"},{"location":"host-functions-mqtt/#host-functions","text":"","title":"Host functions"},{"location":"host-functions-mqtt/#mqtt","text":"You must use the \"mqtt\" mode of Capsule as the MQTT connection is defined at the start of Capsule and shared with the WASM module: 1 2 3 4 5 6 capsule \\ -wasm = ../wasm_modules/capsule-mqtt-subscriber/hello.wasm \\ -mode = mqtt \\ -mqttsrv = 127 .0.0.1:1883 \\ -topic = topic/sensor0 \\ -clientId = sensor_id1","title":"MQTT"},{"location":"host-functions-mqtt/#mqtt-handler-as-a-subscriber","text":"\ud83d\udd90 you have to call hf.OnMqttMessage(Handle) from the main function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package main import ( hf \"github.com/bots-garden/capsule/capsulemodule/hostfunctions\" ) // the topic is defined when launching the capsule launcher func main () { hf . OnMqttMessage ( Handle ) } func Handle ( params [] string ) { message := params [ 0 ] hf . Log ( \"\ud83d\udc4b you get a message on topic \" + hf . MqttGetTopic () + \": \" + message ) // we use the connection of the launcher (capsule) _ , err := hf . MqttPublish ( \"topic/reply\" , \"it's a wasm module here\" ) if err != nil { hf . Log ( \"\ud83d\ude21 ouch something bad is happening\" ) hf . Log ( err . Error ()) } }","title":"MQTT Handler as a Subscriber"},{"location":"host-functions-nats/","text":"Host functions Nats NatsPublish(subject string, message string) : publish a message on a subject 1 _ , err := hf . NatsPublish ( \"notify\" , \"it's a wasm module here\" ) You must use the \"nats\" mode of Capsule as the NATS connection is defined at the start of Capsule and shared with the WASM module: 1 2 3 4 5 capsule \\ -wasm = ../wasm_modules/capsule-nats-subscriber/hello.wasm \\ -mode = nats \\ -natssrv = nats.devsecops.fun:4222 \\ -subject = ping NatsReply(message string, timeout uint32) : publish a message on the current subject and wait for an answer 1 _ , err := hf . NatsReply ( \"it's a wasm module here\" , 10 ) You must use the \"nats\" mode of Capsule as the NATS connection and the subscription are defined at the start of Capsule and shared with the WASM module. NatsGetSubject() : get the subject listened by the Capsule launcher 1 hf . Log ( \"\ud83d\udc42Listening on: \" + hf . NatsGetSubject ()) NatsGetServer() : get the connected NATS server 1 hf . Log ( \"\ud83d\udc4b NATS server: \" + hf . NatsGetServer ()) NatsConnectPublish(server string, subject string, message string) : connect to a NATS server and send a message on a subject 1 _ , err := hf . NatsConnectPublish ( \"nats.devsecops.fun:4222\" , \"ping\" , \"\ud83d\udd90 Hello from WASM with Nats \ud83d\udc9c\" ) You can use this function with all the running modes of Capsule NatsConnectPublish(server string, subject string, message string, timeout uint32) : connect to a NATS server and send a message on a subject 1 answer , err := hf . NatsConnectRequest ( \"nats.devsecops.fun:4222\" , \"notify\" , \"\ud83d\udc4b Hello World \ud83c\udf0d\" , 1 ) You can use this function with all the running modes of Capsule","title":"Nats"},{"location":"host-functions-nats/#host-functions","text":"","title":"Host functions"},{"location":"host-functions-nats/#nats","text":"NatsPublish(subject string, message string) : publish a message on a subject 1 _ , err := hf . NatsPublish ( \"notify\" , \"it's a wasm module here\" ) You must use the \"nats\" mode of Capsule as the NATS connection is defined at the start of Capsule and shared with the WASM module: 1 2 3 4 5 capsule \\ -wasm = ../wasm_modules/capsule-nats-subscriber/hello.wasm \\ -mode = nats \\ -natssrv = nats.devsecops.fun:4222 \\ -subject = ping NatsReply(message string, timeout uint32) : publish a message on the current subject and wait for an answer 1 _ , err := hf . NatsReply ( \"it's a wasm module here\" , 10 ) You must use the \"nats\" mode of Capsule as the NATS connection and the subscription are defined at the start of Capsule and shared with the WASM module. NatsGetSubject() : get the subject listened by the Capsule launcher 1 hf . Log ( \"\ud83d\udc42Listening on: \" + hf . NatsGetSubject ()) NatsGetServer() : get the connected NATS server 1 hf . Log ( \"\ud83d\udc4b NATS server: \" + hf . NatsGetServer ()) NatsConnectPublish(server string, subject string, message string) : connect to a NATS server and send a message on a subject 1 _ , err := hf . NatsConnectPublish ( \"nats.devsecops.fun:4222\" , \"ping\" , \"\ud83d\udd90 Hello from WASM with Nats \ud83d\udc9c\" ) You can use this function with all the running modes of Capsule NatsConnectPublish(server string, subject string, message string, timeout uint32) : connect to a NATS server and send a message on a subject 1 answer , err := hf . NatsConnectRequest ( \"nats.devsecops.fun:4222\" , \"notify\" , \"\ud83d\udc4b Hello World \ud83c\udf0d\" , 1 ) You can use this function with all the running modes of Capsule","title":"Nats"},{"location":"host-functions-redis/","text":"Host functions Make Redis queries \ud83d\udea7 this is a work in progress You need to run Capsule with these two environment variables: 1 2 REDIS_ADDR = \"localhost:6379\" REDIS_PWD = \"\" SET 1 2 3 4 5 6 7 // add a key, value res , err := hf . RedisSet ( \"greetings\" , \"Hello World\" ) if err != nil { hf . Log ( err . Error ()) } else { hf . Log ( \"Value: \" + res ) } GET 1 2 3 4 5 6 7 // read the value res , err := hf . RedisGet ( \"greetings\" ) if err != nil { hf . Log ( err . Error ()) } else { hf . Log ( \"Value: \" + res ) } KEYS 1 2 3 4 5 6 7 8 legion , err := hf . RedisKeys ( \"bob*\" ) if err != nil { hf . Log ( err . Error ()) } for _ , bob := range legion { hf . Log ( bob ) }","title":"Redis"},{"location":"host-functions-redis/#host-functions","text":"","title":"Host functions"},{"location":"host-functions-redis/#make-redis-queries","text":"\ud83d\udea7 this is a work in progress You need to run Capsule with these two environment variables: 1 2 REDIS_ADDR = \"localhost:6379\" REDIS_PWD = \"\" SET 1 2 3 4 5 6 7 // add a key, value res , err := hf . RedisSet ( \"greetings\" , \"Hello World\" ) if err != nil { hf . Log ( err . Error ()) } else { hf . Log ( \"Value: \" + res ) } GET 1 2 3 4 5 6 7 // read the value res , err := hf . RedisGet ( \"greetings\" ) if err != nil { hf . Log ( err . Error ()) } else { hf . Log ( \"Value: \" + res ) } KEYS 1 2 3 4 5 6 7 8 legion , err := hf . RedisKeys ( \"bob*\" ) if err != nil { hf . Log ( err . Error ()) } for _ , bob := range legion { hf . Log ( bob ) }","title":"Make Redis queries"},{"location":"install/","text":"Install Capsule Before executing or running a function, you need to install the last release of Capsule : The script will install Capsule in $HOME/.local/bin if you want to install Capsule somewhere else, override the CAPSULE_PATH variable (default value: CAPSULE_PATH=\"$HOME/.local/bin\" ) \ud83d\udd90 On Linux : 1 2 export CAPSULE_VERSION = \"v0.2.9\" wget -O - https://raw.githubusercontent.com/bots-garden/capsule/ ${ CAPSULE_VERSION } /install-capsule-launcher.sh | bash \ud83d\udd90 On macOS : create the $HOME/.local/bin directory add it to your path: 1 2 export CAPSULE_RUNNER_PATH = \" $HOME /.local\" export PATH = \" $CAPSULE_RUNNER_PATH /bin: $PATH \" Then you can serve a wasm function like this: 1 2 3 4 MESSAGE = \"\ud83d\udc4b Hello World \ud83c\udf0d\" capsule \\ -wasm = ./app/index.wasm \\ -mode = http \\ -httpPort = 8080 You can download the appropriate release of Capsule here: v0.2.9 \ud83e\udd9c [parrot] Using the Capsule Docker image The documentation is a wip \ud83d\udea7 A \"scratch\" Docker image of Capsule exists on https://hub.docker.com/r/k33g/capsule-launcher/tags . You can find more details on the capsule-docker-image project. This image will be used to deploy Capsule to CaaS or Kubernetes. You can use it directly to run a wasm function without installing Capsule: 1 2 3 4 5 6 7 8 docker run \\ -p 8080 :8080 \\ -e MESSAGE = \"\ud83d\udc4b Hello World \ud83c\udf0d\" \\ -v $( pwd ) :/app --rm k33g/capsule-launcher:0.2.9 \\ /capsule \\ -wasm = ./app/index.wasm \\ -mode = http \\ -httpPort = 8080 \ud83d\udc4b You will find some running examples with these projects: https://github.com/bots-garden/capsule-launcher-demo https://github.com/bots-garden/capsule-hello-universe Old samples to be updated: https://github.com/bots-garden/capsule-samples https://github.com/bots-garden/capsule-on-fly-dot-io","title":"\ud83d\udc8a Install Capsule"},{"location":"install/#install-capsule","text":"Before executing or running a function, you need to install the last release of Capsule : The script will install Capsule in $HOME/.local/bin if you want to install Capsule somewhere else, override the CAPSULE_PATH variable (default value: CAPSULE_PATH=\"$HOME/.local/bin\" ) \ud83d\udd90 On Linux : 1 2 export CAPSULE_VERSION = \"v0.2.9\" wget -O - https://raw.githubusercontent.com/bots-garden/capsule/ ${ CAPSULE_VERSION } /install-capsule-launcher.sh | bash \ud83d\udd90 On macOS : create the $HOME/.local/bin directory add it to your path: 1 2 export CAPSULE_RUNNER_PATH = \" $HOME /.local\" export PATH = \" $CAPSULE_RUNNER_PATH /bin: $PATH \" Then you can serve a wasm function like this: 1 2 3 4 MESSAGE = \"\ud83d\udc4b Hello World \ud83c\udf0d\" capsule \\ -wasm = ./app/index.wasm \\ -mode = http \\ -httpPort = 8080 You can download the appropriate release of Capsule here: v0.2.9 \ud83e\udd9c [parrot]","title":"Install Capsule"},{"location":"install/#using-the-capsule-docker-image","text":"The documentation is a wip \ud83d\udea7 A \"scratch\" Docker image of Capsule exists on https://hub.docker.com/r/k33g/capsule-launcher/tags . You can find more details on the capsule-docker-image project. This image will be used to deploy Capsule to CaaS or Kubernetes. You can use it directly to run a wasm function without installing Capsule: 1 2 3 4 5 6 7 8 docker run \\ -p 8080 :8080 \\ -e MESSAGE = \"\ud83d\udc4b Hello World \ud83c\udf0d\" \\ -v $( pwd ) :/app --rm k33g/capsule-launcher:0.2.9 \\ /capsule \\ -wasm = ./app/index.wasm \\ -mode = http \\ -httpPort = 8080 \ud83d\udc4b You will find some running examples with these projects: https://github.com/bots-garden/capsule-launcher-demo https://github.com/bots-garden/capsule-hello-universe Old samples to be updated: https://github.com/bots-garden/capsule-samples https://github.com/bots-garden/capsule-on-fly-dot-io","title":"Using the Capsule Docker image"},{"location":"references/","text":"References Blog posts Create a GitLab bot with a Capsule Wasm function in less than 100 lines of code Deploy Capsule Functions on Fly.io in a flash A simple calc serverless function with Capsule, NATS and Node.js Host and Serve a Lit SPA with WebAssembly (and Capsule) Capsule, my personal wasm FaaS (part 2) Capsule, my personal wasm multi-tools knife (part 1) Extend Wasm with host functions thanks to Wazero An essay on the bi-directional exchange of strings between the Wasm module (with TinyGo) and Node.js (with WASI support)","title":"\ud83d\udcd9 Refs"},{"location":"references/#references","text":"","title":"References"},{"location":"references/#blog-posts","text":"Create a GitLab bot with a Capsule Wasm function in less than 100 lines of code Deploy Capsule Functions on Fly.io in a flash A simple calc serverless function with Capsule, NATS and Node.js Host and Serve a Lit SPA with WebAssembly (and Capsule) Capsule, my personal wasm FaaS (part 2) Capsule, my personal wasm multi-tools knife (part 1) Extend Wasm with host functions thanks to Wazero An essay on the bi-directional exchange of strings between the Wasm module (with TinyGo) and Node.js (with WASI support)","title":"Blog posts"}]}